import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toPropertyKey from "@babel/runtime/helpers/esm/toPropertyKey";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";

/**
 * Immutable unordered Map like interface of point to value pairs.
 *
 * 
 */
import * as Types from "./types";

/** Sets the value for point in map */
export function set(point, value, map) {
  return _objectSpread({}, map, _defineProperty({}, point.row, _objectSpread({}, map[point.row], _defineProperty({}, point.column, value))));
}
export function unset(_ref, map) {
  var row = _ref.row,
      column = _ref.column;

  if (!(row in map) || !(column in map[row])) {
    return map;
  }

  var _String = String(row),
      _map$_String = map[_String],
      _String2 = String(column),
      _ = _map$_String[_String2],
      nextRow = _objectWithoutProperties(_map$_String, [_String2].map(_toPropertyKey)),
      nextMap = _objectWithoutProperties(map, [_String].map(_toPropertyKey));

  if (Object.keys(nextRow).length === 0) {
    return nextMap;
  }

  return _objectSpread({}, nextMap, _defineProperty({}, row, nextRow));
}
/** Gets the value for point in map */

export function get(point, map) {
  return map[point.row] && map[point.row][point.column];
}
/** Checks if map has point assigned to value */

export function has(point, map) {
  return point.row in map && point.column in map[point.row];
}
export function getRow(row, map) {
  return row in map ? // $FlowFixMe
  Object.keys(map[row]).map(function (column) {
    return map[row][column];
  }) : [];
}
export function getColumn(column, map) {
  // $FlowFixMe
  return Object.keys(map).map(function (row) {
    return map[row][column];
  });
}
var EMPTY = {};
/** Creates a new PointMap instance from an array-like or iterable object. */

export function from(pairs) {
  return pairs.reduce(function (acc, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        point = _ref3[0],
        value = _ref3[1];

    return set(point, value, acc);
  }, EMPTY);
}
/** Creates a new PointMap instance from a Matrix. */

export function fromMatrix(matrix) {
  return matrix.reduce(function (rowAcc, data, row) {
    return data.reduce(function (colAcc, cell, column) {
      return cell ? set({
        row: row,
        column: column
      }, cell, colAcc) : colAcc;
    }, rowAcc);
  }, EMPTY);
}
/** Returns the number of elements in a PointMap object. */

export function size(map) {
  var acc = 0;

  var _map_keys = Object.keys(map);

  for (var i = 0; i < _map_keys.length; i++) {
    var _row = Number(_map_keys[i]);

    var columns = map[_row];
    acc += Object.keys(columns).length;
  }

  return acc;
}
/** Applies a function against an accumulator and each value and point in the map (from left to right) to reduce it to a single value */

export function reduce(func, map, initialValue) {
  var acc = initialValue;

  var _map_keys = Object.keys(map);

  for (var i = 0; i < _map_keys.length; i++) {
    var _row2 = Number(_map_keys[i]);

    var columns = map[_row2];

    var _columns_keys = Object.keys(columns);

    for (var j = 0; j < _columns_keys.length; j++) {
      var _column = Number(_columns_keys[j]);

      var _value = columns[_column];
      acc = func(acc, _value, {
        row: _row2,
        column: _column
      });
    }
  }

  return acc;
}
/** Creates a new map with the results of calling a provided function on every value in the calling map */

export function map(func, map) {
  return reduce(function (acc, value, point) {
    return set(point, func(value), acc);
  }, map, from([]));
}
/** Creates a new map of all values predicate returns truthy for. The predicate is invoked with two arguments: (value, key) */

export function filter(predicate, map) {
  return reduce(function (acc, value, point) {
    if (predicate(value, point)) {
      return set(point, value, acc);
    }

    return acc;
  }, map, from([]));
}
/** Returns whether map has any points set to value */

export function isEmpty(map) {
  return Object.keys(map).length === 0;
}