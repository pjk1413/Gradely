{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport CellCoords from './../cell/coords';\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange = /*#__PURE__*/function () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n\n    _classCallCheck(this, CellRange);\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell when you press Enter.\n     *\n     * @type {CellCoords}\n     */\n\n\n    this.highlight = highlight;\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from;\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to;\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   */\n\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords;\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords;\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords;\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row === this.to.row && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n          col = cellCoords.col;\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getTopLeftCorner()) && this.includes(cellRange.getBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getTopLeftCorner()) && cellRange.isNorthWestOf(this.getBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getTopLeftCorner().isSouthEastOf(cellRange) || this.getBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getTopLeftCorner().isNorthWestOf(cellRange) || this.getBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. the current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getTopRightCorner().col >= cellRange.getTopLeftCorner().col && this.getTopRightCorner().col <= cellRange.getTopRightCorner().col || this.getTopLeftCorner().col <= cellRange.getTopRightCorner().col && this.getTopLeftCorner().col >= cellRange.getTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. the current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getBottomRightCorner().row >= cellRange.getTopRightCorner().row && this.getBottomRightCorner().row <= cellRange.getBottomRightCorner().row || this.getTopRightCorner().row <= cellRange.getBottomRightCorner().row && this.getTopRightCorner().row >= cellRange.getTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getTopLeftCorner();\n      var expandingBottomRight = expandingRange.getBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n\n      if (this.highlight.row === this.getBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n\n      if (this.highlight.col === this.getTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {String} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {String} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getTopLeftCorner(), this.getBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n\n        case 'NE-SW':\n          var _ref2 = [this.getTopRightCorner(), this.getBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n\n        case 'SE-NW':\n          var _ref3 = [this.getBottomRightCorner(), this.getTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n\n        case 'SW-NE':\n          var _ref4 = [this.getBottomLeftCorner(), this.getTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {String} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {String} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n\n      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getBottomRightCorner();\n          }\n\n          if (this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getBottomLeftCorner();\n          }\n\n          if (this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getTopRightCorner();\n          }\n\n          if (this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getTopLeftCorner();\n          }\n        }\n      }\n\n      if (coords.isEqual(this.getBottomRightCorner())) {\n        return this.getTopLeftCorner();\n      } else if (coords.isEqual(this.getTopLeftCorner())) {\n        return this.getBottomRightCorner();\n      } else if (coords.isEqual(this.getTopRightCorner())) {\n        return this.getBottomLeftCorner();\n      } else if (coords.isEqual(this.getBottomLeftCorner())) {\n        return this.getTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function\n     *\n     * @param callback {Function}\n     */\n\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @return {Object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n\n  return CellRange;\n}();\n\nexport default CellRange;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/3rdparty/walkontable/src/cell/range.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","highlight","from","arguments","undefined","to","value","setHighlight","coords","setFrom","setTo","isValid","wot","isSingle","row","col","getHeight","Math","max","min","getWidth","includes","cellCoords","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","isNorthWestOf","isOverlappingHorizontally","getTopRightCorner","isOverlappingVertically","expand","expandByRange","expandingRange","initialDirection","getDirection","expandingTopLeft","expandingBottomRight","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","_ref","_ref2","getBottomLeftCorner","_ref3","_ref4","indexOf","isCorner","expandedRange","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","r","c","getAll","forAll","callback","breakIteration","toObject"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.string.includes\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport CellCoords from './../cell/coords';\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange =\n/*#__PURE__*/\nfunction () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n\n    _classCallCheck(this, CellRange);\n\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell when you press Enter.\n     *\n     * @type {CellCoords}\n     */\n    this.highlight = highlight;\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from;\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to;\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   */\n\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords;\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords;\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords;\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row === this.to.row && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n          col = cellCoords.col;\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getTopLeftCorner()) && this.includes(cellRange.getBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getTopLeftCorner()) && cellRange.isNorthWestOf(this.getBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getTopLeftCorner().isSouthEastOf(cellRange) || this.getBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getTopLeftCorner().isNorthWestOf(cellRange) || this.getBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. the current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getTopRightCorner().col >= cellRange.getTopLeftCorner().col && this.getTopRightCorner().col <= cellRange.getTopRightCorner().col || this.getTopLeftCorner().col <= cellRange.getTopRightCorner().col && this.getTopLeftCorner().col >= cellRange.getTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. the current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getBottomRightCorner().row >= cellRange.getTopRightCorner().row && this.getBottomRightCorner().row <= cellRange.getBottomRightCorner().row || this.getTopRightCorner().row <= cellRange.getBottomRightCorner().row && this.getTopRightCorner().row >= cellRange.getTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getTopLeftCorner();\n      var expandingBottomRight = expandingRange.getBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n\n      if (this.highlight.row === this.getBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n\n      if (this.highlight.col === this.getTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {String} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {String} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getTopLeftCorner(), this.getBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n\n        case 'NE-SW':\n          var _ref2 = [this.getTopRightCorner(), this.getBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n\n        case 'SE-NW':\n          var _ref3 = [this.getBottomRightCorner(), this.getTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n\n        case 'SW-NE':\n          var _ref4 = [this.getBottomLeftCorner(), this.getTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {String} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {String} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n\n      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getBottomRightCorner();\n          }\n\n          if (this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getBottomLeftCorner();\n          }\n\n          if (this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getTopRightCorner();\n          }\n\n          if (this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getTopLeftCorner();\n          }\n        }\n      }\n\n      if (coords.isEqual(this.getBottomRightCorner())) {\n        return this.getTopLeftCorner();\n      } else if (coords.isEqual(this.getTopLeftCorner())) {\n        return this.getBottomRightCorner();\n      } else if (coords.isEqual(this.getTopRightCorner())) {\n        return this.getBottomLeftCorner();\n      } else if (coords.isEqual(this.getBottomLeftCorner())) {\n        return this.getTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function\n     *\n     * @param callback {Function}\n     */\n\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @return {Object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n\n  return CellRange;\n}();\n\nexport default CellRange;"]},"metadata":{},"sourceType":"module"}