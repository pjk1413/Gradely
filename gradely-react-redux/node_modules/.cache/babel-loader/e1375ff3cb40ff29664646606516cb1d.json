{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { createHighlight } from './types';\nimport { arrayEach } from './../../helpers/array';\nexport var ACTIVE_HEADER_TYPE = 'active-header';\nexport var AREA_TYPE = 'area';\nexport var CELL_TYPE = 'cell';\nexport var FILL_TYPE = 'fill';\nexport var HEADER_TYPE = 'header';\nexport var CUSTOM_SELECTION = 'custom-selection';\n/**\n * Highlight class responsible for managing Walkontable Selection classes.\n *\n * With Highlight object you can manipulate four different highlight types:\n *  - `cell` can be added only to a single cell at a time and it defines currently selected cell;\n *  - `fill` can occur only once and its highlight defines selection of autofill functionality (managed by the plugin with the same name);\n *  - `areas` can be added to multiple cells at a time. This type highlights selected cell or multiple cells.\n *    The multiple cells have to be defined as an uninterrupted order (regular shape). Otherwise, the new layer of\n *    that type should be created to manage not-consecutive selection;\n *  - `header` can occur multiple times. This type is designed to highlight only headers. Like `area` type it\n *    can appear with multiple highlights (accessed under different level layers).\n *\n * @class Highlight\n * @util\n */\n\nvar Highlight = /*#__PURE__*/function () {\n  function Highlight(options) {\n    _classCallCheck(this, Highlight);\n    /**\n     * Options consumed by Highlight class and Walkontable Selection classes.\n     *\n     * @type {Object}\n     */\n\n\n    this.options = options;\n    /**\n     * The property which describes which layer level of the visual selection will be modified.\n     * This option is valid only for `area` and `header` highlight types which occurs multiple times on\n     * the table (as a non-consecutive selection).\n     *\n     * An order of the layers is the same as the order of added new non-consecutive selections.\n     *\n     * @type {Number}\n     * @default 0\n     */\n\n    this.layerLevel = 0;\n    /**\n     * `cell` highlight object which describes attributes for the currently selected cell.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n\n    this.cell = createHighlight(CELL_TYPE, options);\n    /**\n     * `fill` highlight object which describes attributes for the borders for autofill functionality.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n\n    this.fill = createHighlight(FILL_TYPE, options);\n    /**\n     * Collection of the `area` highlights. That objects describes attributes for the borders and selection of\n     * the multiple selected cells. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.areas = new Map();\n    /**\n     * Collection of the `header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows and columns in the table header. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.headers = new Map();\n    /**\n     * Collection of the `active-header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows and columns in the table header. The table headers which have selected all items in\n     * a row will be marked as `active-header`.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.activeHeaders = new Map();\n    /**\n     * Collection of the `custom-selection`, holder for example borders added through CustomBorders plugin.\n     *\n     * @type {Selection[]}\n     */\n\n    this.customSelections = [];\n  }\n  /**\n   * Check if highlight cell rendering is disabled for specyfied highlight type.\n   *\n   * @param {String} highlightType Highlight type. Possible values are: `cell`, `area`, `fill` or `header`.\n   * @return {Boolean}\n   */\n\n\n  _createClass(Highlight, [{\n    key: \"isEnabledFor\",\n    value: function isEnabledFor(highlightType) {\n      // Legacy compatibility.\n      var type = highlightType === 'current' ? CELL_TYPE : highlightType;\n      var disableHighlight = this.options.disableHighlight;\n\n      if (typeof disableHighlight === 'string') {\n        disableHighlight = [disableHighlight];\n      }\n\n      return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);\n    }\n    /**\n     * Set a new layer level to make access to the desire `area` and `header` highlights.\n     *\n     * @param {Number} [level=0] Layer level to use.\n     * @returns {Highlight}\n     */\n\n  }, {\n    key: \"useLayerLevel\",\n    value: function useLayerLevel() {\n      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.layerLevel = level;\n      return this;\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the currently selected/edited cell.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell() {\n      return this.cell;\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getFill\",\n    value: function getFill() {\n      return this.fill;\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetArea\",\n    value: function createOrGetArea() {\n      var layerLevel = this.layerLevel;\n      var area;\n\n      if (this.areas.has(layerLevel)) {\n        area = this.areas.get(layerLevel);\n      } else {\n        area = createHighlight(AREA_TYPE, _objectSpread({\n          layerLevel: layerLevel\n        }, this.options));\n        this.areas.set(layerLevel, area);\n      }\n\n      return area;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getAreas\",\n    value: function getAreas() {\n      return _toConsumableArray(this.areas.values());\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected header cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetHeader\",\n    value: function createOrGetHeader() {\n      var layerLevel = this.layerLevel;\n      var header;\n\n      if (this.headers.has(layerLevel)) {\n        header = this.headers.get(layerLevel);\n      } else {\n        header = createHighlight(HEADER_TYPE, _objectSpread({}, this.options));\n        this.headers.set(layerLevel, header);\n      }\n\n      return header;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      return _toConsumableArray(this.headers.values());\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected active header cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetActiveHeader\",\n    value: function createOrGetActiveHeader() {\n      var layerLevel = this.layerLevel;\n      var header;\n\n      if (this.activeHeaders.has(layerLevel)) {\n        header = this.activeHeaders.get(layerLevel);\n      } else {\n        header = createHighlight(ACTIVE_HEADER_TYPE, _objectSpread({}, this.options));\n        this.activeHeaders.set(layerLevel, header);\n      }\n\n      return header;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getActiveHeaders\",\n    value: function getActiveHeaders() {\n      return _toConsumableArray(this.activeHeaders.values());\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getCustomSelections\",\n    value: function getCustomSelections() {\n      return _toConsumableArray(this.customSelections.values());\n    }\n    /**\n     * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: \"addCustomSelection\",\n    value: function addCustomSelection(options) {\n      this.customSelections.push(createHighlight(CUSTOM_SELECTION, _objectSpread({}, options)));\n    }\n    /**\n     * Perform cleaning visual highlights for the whole table.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cell.clear();\n      this.fill.clear();\n      arrayEach(this.areas.values(), function (highlight) {\n        return void highlight.clear();\n      });\n      arrayEach(this.headers.values(), function (highlight) {\n        return void highlight.clear();\n      });\n      arrayEach(this.activeHeaders.values(), function (highlight) {\n        return void highlight.clear();\n      });\n    }\n    /**\n     * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return [this.cell, this.fill].concat(_toConsumableArray(this.areas.values()), _toConsumableArray(this.headers.values()), _toConsumableArray(this.activeHeaders.values()), _toConsumableArray(this.customSelections))[Symbol.iterator]();\n    }\n  }]);\n\n  return Highlight;\n}();\n\nexport default Highlight;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/selection/highlight/highlight.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","createHighlight","arrayEach","ACTIVE_HEADER_TYPE","AREA_TYPE","CELL_TYPE","FILL_TYPE","HEADER_TYPE","CUSTOM_SELECTION","Highlight","options","layerLevel","cell","fill","areas","Map","headers","activeHeaders","customSelections","isEnabledFor","highlightType","type","disableHighlight","includes","useLayerLevel","level","undefined","getCell","getFill","createOrGetArea","area","has","get","set","getAreas","values","createOrGetHeader","header","getHeaders","createOrGetActiveHeader","getActiveHeaders","getCustomSelections","addCustomSelection","clear","highlight","concat"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.fill\";\nimport \"core-js/modules/es.array.filter\";\nimport \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.map\";\nimport \"core-js/modules/es.object.get-own-property-descriptor\";\nimport \"core-js/modules/es.object.get-own-property-descriptors\";\nimport \"core-js/modules/es.object.keys\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { createHighlight } from './types';\nimport { arrayEach } from './../../helpers/array';\nexport var ACTIVE_HEADER_TYPE = 'active-header';\nexport var AREA_TYPE = 'area';\nexport var CELL_TYPE = 'cell';\nexport var FILL_TYPE = 'fill';\nexport var HEADER_TYPE = 'header';\nexport var CUSTOM_SELECTION = 'custom-selection';\n/**\n * Highlight class responsible for managing Walkontable Selection classes.\n *\n * With Highlight object you can manipulate four different highlight types:\n *  - `cell` can be added only to a single cell at a time and it defines currently selected cell;\n *  - `fill` can occur only once and its highlight defines selection of autofill functionality (managed by the plugin with the same name);\n *  - `areas` can be added to multiple cells at a time. This type highlights selected cell or multiple cells.\n *    The multiple cells have to be defined as an uninterrupted order (regular shape). Otherwise, the new layer of\n *    that type should be created to manage not-consecutive selection;\n *  - `header` can occur multiple times. This type is designed to highlight only headers. Like `area` type it\n *    can appear with multiple highlights (accessed under different level layers).\n *\n * @class Highlight\n * @util\n */\n\nvar Highlight =\n/*#__PURE__*/\nfunction () {\n  function Highlight(options) {\n    _classCallCheck(this, Highlight);\n\n    /**\n     * Options consumed by Highlight class and Walkontable Selection classes.\n     *\n     * @type {Object}\n     */\n    this.options = options;\n    /**\n     * The property which describes which layer level of the visual selection will be modified.\n     * This option is valid only for `area` and `header` highlight types which occurs multiple times on\n     * the table (as a non-consecutive selection).\n     *\n     * An order of the layers is the same as the order of added new non-consecutive selections.\n     *\n     * @type {Number}\n     * @default 0\n     */\n\n    this.layerLevel = 0;\n    /**\n     * `cell` highlight object which describes attributes for the currently selected cell.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n\n    this.cell = createHighlight(CELL_TYPE, options);\n    /**\n     * `fill` highlight object which describes attributes for the borders for autofill functionality.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n\n    this.fill = createHighlight(FILL_TYPE, options);\n    /**\n     * Collection of the `area` highlights. That objects describes attributes for the borders and selection of\n     * the multiple selected cells. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.areas = new Map();\n    /**\n     * Collection of the `header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows and columns in the table header. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.headers = new Map();\n    /**\n     * Collection of the `active-header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows and columns in the table header. The table headers which have selected all items in\n     * a row will be marked as `active-header`.\n     *\n     * @type {Map.<number, Selection>}\n     */\n\n    this.activeHeaders = new Map();\n    /**\n     * Collection of the `custom-selection`, holder for example borders added through CustomBorders plugin.\n     *\n     * @type {Selection[]}\n     */\n\n    this.customSelections = [];\n  }\n  /**\n   * Check if highlight cell rendering is disabled for specyfied highlight type.\n   *\n   * @param {String} highlightType Highlight type. Possible values are: `cell`, `area`, `fill` or `header`.\n   * @return {Boolean}\n   */\n\n\n  _createClass(Highlight, [{\n    key: \"isEnabledFor\",\n    value: function isEnabledFor(highlightType) {\n      // Legacy compatibility.\n      var type = highlightType === 'current' ? CELL_TYPE : highlightType;\n      var disableHighlight = this.options.disableHighlight;\n\n      if (typeof disableHighlight === 'string') {\n        disableHighlight = [disableHighlight];\n      }\n\n      return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);\n    }\n    /**\n     * Set a new layer level to make access to the desire `area` and `header` highlights.\n     *\n     * @param {Number} [level=0] Layer level to use.\n     * @returns {Highlight}\n     */\n\n  }, {\n    key: \"useLayerLevel\",\n    value: function useLayerLevel() {\n      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.layerLevel = level;\n      return this;\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the currently selected/edited cell.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell() {\n      return this.cell;\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getFill\",\n    value: function getFill() {\n      return this.fill;\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetArea\",\n    value: function createOrGetArea() {\n      var layerLevel = this.layerLevel;\n      var area;\n\n      if (this.areas.has(layerLevel)) {\n        area = this.areas.get(layerLevel);\n      } else {\n        area = createHighlight(AREA_TYPE, _objectSpread({\n          layerLevel: layerLevel\n        }, this.options));\n        this.areas.set(layerLevel, area);\n      }\n\n      return area;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getAreas\",\n    value: function getAreas() {\n      return _toConsumableArray(this.areas.values());\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected header cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetHeader\",\n    value: function createOrGetHeader() {\n      var layerLevel = this.layerLevel;\n      var header;\n\n      if (this.headers.has(layerLevel)) {\n        header = this.headers.get(layerLevel);\n      } else {\n        header = createHighlight(HEADER_TYPE, _objectSpread({}, this.options));\n        this.headers.set(layerLevel, header);\n      }\n\n      return header;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      return _toConsumableArray(this.headers.values());\n    }\n    /**\n     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight\n     * of the multiple selected active header cells.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"createOrGetActiveHeader\",\n    value: function createOrGetActiveHeader() {\n      var layerLevel = this.layerLevel;\n      var header;\n\n      if (this.activeHeaders.has(layerLevel)) {\n        header = this.activeHeaders.get(layerLevel);\n      } else {\n        header = createHighlight(ACTIVE_HEADER_TYPE, _objectSpread({}, this.options));\n        this.activeHeaders.set(layerLevel, header);\n      }\n\n      return header;\n    }\n    /**\n     * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.\n     *\n     * @return {Selection[]}\n     */\n\n  }, {\n    key: \"getActiveHeaders\",\n    value: function getActiveHeaders() {\n      return _toConsumableArray(this.activeHeaders.values());\n    }\n    /**\n     * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: \"getCustomSelections\",\n    value: function getCustomSelections() {\n      return _toConsumableArray(this.customSelections.values());\n    }\n    /**\n     * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.\n     *\n     * @param {Object} options\n     */\n\n  }, {\n    key: \"addCustomSelection\",\n    value: function addCustomSelection(options) {\n      this.customSelections.push(createHighlight(CUSTOM_SELECTION, _objectSpread({}, options)));\n    }\n    /**\n     * Perform cleaning visual highlights for the whole table.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cell.clear();\n      this.fill.clear();\n      arrayEach(this.areas.values(), function (highlight) {\n        return void highlight.clear();\n      });\n      arrayEach(this.headers.values(), function (highlight) {\n        return void highlight.clear();\n      });\n      arrayEach(this.activeHeaders.values(), function (highlight) {\n        return void highlight.clear();\n      });\n    }\n    /**\n     * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return [this.cell, this.fill].concat(_toConsumableArray(this.areas.values()), _toConsumableArray(this.headers.values()), _toConsumableArray(this.activeHeaders.values()), _toConsumableArray(this.customSelections))[Symbol.iterator]();\n    }\n  }]);\n\n  return Highlight;\n}();\n\nexport default Highlight;"]},"metadata":{},"sourceType":"module"}