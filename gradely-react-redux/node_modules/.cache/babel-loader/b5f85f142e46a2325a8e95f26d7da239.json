{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { getProperty } from './helpers/object';\nimport { arrayEach } from './helpers/array';\nimport { rangeEach } from './helpers/number';\n/**\n * @class DataSource\n * @private\n */\n\nvar DataSource = /*#__PURE__*/function () {\n  function DataSource(hotInstance) {\n    var dataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, DataSource);\n    /**\n     * Instance of Handsontable.\n     *\n     * @type {Handsontable}\n     */\n\n\n    this.hot = hotInstance;\n    /**\n     * Data source\n     *\n     * @type {Array}\n     */\n\n    this.data = dataSource;\n    /**\n     * Type of data source.\n     *\n     * @type {String}\n     * @default 'array'\n     */\n\n    this.dataType = 'array';\n\n    this.colToProp = function () {};\n\n    this.propToCol = function () {};\n  }\n  /**\n   * Get all data.\n   *\n   * @param {Boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n   *                                  in another format.\n   * @returns {Array}\n   */\n\n\n  _createClass(DataSource, [{\n    key: \"getData\",\n    value: function getData() {\n      var toArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var result = this.data;\n\n      if (toArray) {\n        result = this.getByRange({\n          row: 0,\n          col: 0\n        }, {\n          row: Math.max(this.countRows() - 1, 0),\n          col: Math.max(this.countColumns() - 1, 0)\n        }, true);\n      }\n\n      return result;\n    }\n    /**\n     * Set new data source.\n     *\n     * @param data {Array}\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Returns array of column values from the data source. `column` is the index of the row in the data source.\n     *\n     * @param {Number} column Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAtColumn\",\n    value: function getAtColumn(column) {\n      var _this = this;\n\n      var result = [];\n      arrayEach(this.data, function (row) {\n        var property = _this.colToProp(column);\n\n        var value;\n\n        if (typeof property === 'string') {\n          value = getProperty(row, property);\n        } else if (typeof property === 'function') {\n          value = property(row);\n        } else {\n          value = row[property];\n        }\n\n        result.push(value);\n      });\n      return result;\n    }\n    /**\n     * Returns a single row of the data (array or object, depending on what you have). `row` is the index of the row in the data source.\n     *\n     * @param {Number} row Physical row index.\n     * @returns {Array|Object}\n     */\n\n  }, {\n    key: \"getAtRow\",\n    value: function getAtRow(row) {\n      return this.data[row];\n    }\n    /**\n     * Returns a single value from the data.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getAtCell\",\n    value: function getAtCell(row, column) {\n      var result = null;\n      var modifyRowData = this.hot.runHooks('modifyRowData', row);\n      var dataRow = isNaN(modifyRowData) ? modifyRowData : this.data[row];\n\n      if (dataRow) {\n        var prop = this.colToProp(column);\n\n        if (typeof prop === 'string') {\n          result = getProperty(dataRow, prop);\n        } else if (typeof prop === 'function') {\n          result = prop(this.data.slice(row, row + 1)[0]);\n        } else {\n          result = dataRow[prop];\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns source data by passed range.\n     *\n     * @param {Object} start Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {Object} end Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {Boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(start, end) {\n      var _this2 = this;\n\n      var toArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var startRow = Math.min(start.row, end.row);\n      var startCol = Math.min(start.col, end.col);\n      var endRow = Math.max(start.row, end.row);\n      var endCol = Math.max(start.col, end.col);\n      var result = [];\n      rangeEach(startRow, endRow, function (currentRow) {\n        var row = _this2.getAtRow(currentRow);\n\n        var newRow;\n\n        if (_this2.dataType === 'array') {\n          newRow = row.slice(startCol, endCol + 1);\n        } else if (_this2.dataType === 'object') {\n          newRow = toArray ? [] : {};\n          rangeEach(startCol, endCol, function (column) {\n            var prop = _this2.colToProp(column);\n\n            if (toArray) {\n              newRow.push(row[prop]);\n            } else {\n              newRow[prop] = row[prop];\n            }\n          });\n        }\n\n        result.push(newRow);\n      });\n      return result;\n    }\n    /**\n     * Count number of rows.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"countRows\",\n    value: function countRows() {\n      return Array.isArray(this.data) ? this.data.length : 0;\n    }\n    /**\n     * Count number of columns.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"countColumns\",\n    value: function countColumns() {\n      var result = 0;\n\n      if (Array.isArray(this.data)) {\n        if (this.dataType === 'array') {\n          result = this.data[0].length;\n        } else if (this.dataType === 'object') {\n          result = Object.keys(this.data[0]).length;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.data = null;\n      this.hot = null;\n    }\n  }]);\n\n  return DataSource;\n}();\n\nexport default DataSource;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/dataSource.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getProperty","arrayEach","rangeEach","DataSource","hotInstance","dataSource","arguments","undefined","hot","data","dataType","colToProp","propToCol","value","getData","toArray","result","getByRange","row","col","Math","max","countRows","countColumns","setData","getAtColumn","column","_this","property","push","getAtRow","getAtCell","modifyRowData","runHooks","dataRow","isNaN","prop","slice","start","end","_this2","startRow","min","startCol","endRow","endCol","currentRow","newRow","Array","isArray","keys","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.object.keys\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { getProperty } from './helpers/object';\nimport { arrayEach } from './helpers/array';\nimport { rangeEach } from './helpers/number';\n/**\n * @class DataSource\n * @private\n */\n\nvar DataSource =\n/*#__PURE__*/\nfunction () {\n  function DataSource(hotInstance) {\n    var dataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, DataSource);\n\n    /**\n     * Instance of Handsontable.\n     *\n     * @type {Handsontable}\n     */\n    this.hot = hotInstance;\n    /**\n     * Data source\n     *\n     * @type {Array}\n     */\n\n    this.data = dataSource;\n    /**\n     * Type of data source.\n     *\n     * @type {String}\n     * @default 'array'\n     */\n\n    this.dataType = 'array';\n\n    this.colToProp = function () {};\n\n    this.propToCol = function () {};\n  }\n  /**\n   * Get all data.\n   *\n   * @param {Boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n   *                                  in another format.\n   * @returns {Array}\n   */\n\n\n  _createClass(DataSource, [{\n    key: \"getData\",\n    value: function getData() {\n      var toArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var result = this.data;\n\n      if (toArray) {\n        result = this.getByRange({\n          row: 0,\n          col: 0\n        }, {\n          row: Math.max(this.countRows() - 1, 0),\n          col: Math.max(this.countColumns() - 1, 0)\n        }, true);\n      }\n\n      return result;\n    }\n    /**\n     * Set new data source.\n     *\n     * @param data {Array}\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Returns array of column values from the data source. `column` is the index of the row in the data source.\n     *\n     * @param {Number} column Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAtColumn\",\n    value: function getAtColumn(column) {\n      var _this = this;\n\n      var result = [];\n      arrayEach(this.data, function (row) {\n        var property = _this.colToProp(column);\n\n        var value;\n\n        if (typeof property === 'string') {\n          value = getProperty(row, property);\n        } else if (typeof property === 'function') {\n          value = property(row);\n        } else {\n          value = row[property];\n        }\n\n        result.push(value);\n      });\n      return result;\n    }\n    /**\n     * Returns a single row of the data (array or object, depending on what you have). `row` is the index of the row in the data source.\n     *\n     * @param {Number} row Physical row index.\n     * @returns {Array|Object}\n     */\n\n  }, {\n    key: \"getAtRow\",\n    value: function getAtRow(row) {\n      return this.data[row];\n    }\n    /**\n     * Returns a single value from the data.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getAtCell\",\n    value: function getAtCell(row, column) {\n      var result = null;\n      var modifyRowData = this.hot.runHooks('modifyRowData', row);\n      var dataRow = isNaN(modifyRowData) ? modifyRowData : this.data[row];\n\n      if (dataRow) {\n        var prop = this.colToProp(column);\n\n        if (typeof prop === 'string') {\n          result = getProperty(dataRow, prop);\n        } else if (typeof prop === 'function') {\n          result = prop(this.data.slice(row, row + 1)[0]);\n        } else {\n          result = dataRow[prop];\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns source data by passed range.\n     *\n     * @param {Object} start Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {Object} end Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).\n     * @param {Boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided\n     *                                  in another format.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(start, end) {\n      var _this2 = this;\n\n      var toArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var startRow = Math.min(start.row, end.row);\n      var startCol = Math.min(start.col, end.col);\n      var endRow = Math.max(start.row, end.row);\n      var endCol = Math.max(start.col, end.col);\n      var result = [];\n      rangeEach(startRow, endRow, function (currentRow) {\n        var row = _this2.getAtRow(currentRow);\n\n        var newRow;\n\n        if (_this2.dataType === 'array') {\n          newRow = row.slice(startCol, endCol + 1);\n        } else if (_this2.dataType === 'object') {\n          newRow = toArray ? [] : {};\n          rangeEach(startCol, endCol, function (column) {\n            var prop = _this2.colToProp(column);\n\n            if (toArray) {\n              newRow.push(row[prop]);\n            } else {\n              newRow[prop] = row[prop];\n            }\n          });\n        }\n\n        result.push(newRow);\n      });\n      return result;\n    }\n    /**\n     * Count number of rows.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"countRows\",\n    value: function countRows() {\n      return Array.isArray(this.data) ? this.data.length : 0;\n    }\n    /**\n     * Count number of columns.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"countColumns\",\n    value: function countColumns() {\n      var result = 0;\n\n      if (Array.isArray(this.data)) {\n        if (this.dataType === 'array') {\n          result = this.data[0].length;\n        } else if (this.dataType === 'object') {\n          result = Object.keys(this.data[0]).length;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.data = null;\n      this.hot = null;\n    }\n  }]);\n\n  return DataSource;\n}();\n\nexport default DataSource;"]},"metadata":{},"sourceType":"module"}