{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { arrayEach } from '../../helpers/array';\nimport { warn } from '../../helpers/console';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Class used to make all endpoint-related operations.\n *\n * @class Endpoints\n * @plugin ColumnSummary\n */\n\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n    /**\n     * The main plugin instance.\n     */\n\n\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {Object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {Object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {Object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n    /**\n     * A `recordTranslator` instance.\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {Number} index Index of the endpoint.\n   * @returns {Object}\n   */\n\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     */\n\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n\n      var endpointsArray = [];\n      var settingsArray = settings;\n\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {Object} settings Object with the settings.\n     * @param {Object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {String} name Settings name.\n     * @param defaultValue Default value for the settings.\n     */\n\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     */\n\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * afterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {String} [source] Source of change.\n     * @param {Boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeRenderCallback = function beforeRenderCallback() {\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\n\n          return _this2.refreshAllEndpoints();\n        };\n\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n\n          _this2.recreatePhysicalRanges(endpoint);\n\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {Object} endpoint And endpoint object.\n     */\n\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {Object} endpoint The endpoint object.\n     * @param {Number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {Number} previousPosition Previous endpoint result position.\n     * @param {Number} offset Offset generated by the alteration.\n     */\n\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {Object} endpoint An endpoint object.\n     */\n\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.recordTranslator.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.recordTranslator.toPhysicalRow(range[0]));\n        }\n\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {Object} endpoint Endpoint object.\n     * @param {Number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} endpoints Array containing the endpoints.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints(endpoints) {\n      var _this4 = this;\n\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var endpointsArray = endpoints;\n      this.cellsToSetCache = [];\n\n      if (!endpointsArray) {\n        endpointsArray = this.getAllEndpoints();\n      }\n\n      arrayEach(endpointsArray, function (value) {\n        _this4.resetEndpointValue(value, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n\n        _this5.plugin.calculate(value);\n\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     */\n\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n\n      var _this$recordTranslato = this.recordTranslator.toVisual(endpoint.destinationRow, endpoint.destinationColumn),\n          _this$recordTranslato2 = _slicedToArray(_this$recordTranslato, 2),\n          visualRowIndex = _this$recordTranslato2[0],\n          visualColumnIndex = _this$recordTranslato2[1]; // Clear the meta on the \"old\" indexes\n\n\n      var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n      cellMeta.readOnly = false;\n      cellMeta.className = '';\n      this.cellsToSetCache.push([this.recordTranslator.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.recordTranslator.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {String} [source] Source of the call information.\n     * @param {Boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.getVisualRowIndex(endpoint.destinationRow);\n      var cellMeta = this.hot.getCellMeta(this.getVisualRowIndex(endpoint.destinationRow + reverseRowOffset), endpoint.destinationColumn + reverseColOffset);\n\n      if (visualEndpointRowIndex > this.hot.countRows() || endpoint.destinationColumn > this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Get the visual row index for the provided row. Uses the `umodifyRow` hook.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualRowIndex\",\n    value: function getVisualRowIndex(row) {\n      return this.hot.runHooks('unmodifyRow', row, 'columnSummary');\n    }\n    /**\n     * Get the visual column index for the provided column. Uses the `umodifyColumn` hook.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualColumnIndex\",\n    value: function getVisualColumnIndex(column) {\n      return this.hot.runHooks('unmodifyCol', column, 'columnSummary');\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the  Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n\n  return Endpoints;\n}();\n\nexport default Endpoints;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/plugins/columnSummary/endpoints.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","arrayEach","warn","getTranslator","Endpoints","plugin","settings","hot","endpoints","settingsType","currentEndpoint","cellsToSetCache","recordTranslator","getEndpoint","index","fillMissingEndpointData","getAllEndpoints","func","parseSettings","_this","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","endpoint","name","defaultValue","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","_this2","forceRefresh","arguments","beforeRenderCallback","removeHook","refreshAllEndpoints","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","_this3","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","_this4","useOffset","resetEndpointValue","setDataAtCell","_this5","calculate","setEndpointValue","refreshChangedEndpoints","changes","_this6","needToRefresh","changesObj","concat","propToCol","refreshEndpoint","alterColOffset","_this$recordTranslato","toVisual","_this$recordTranslato2","visualRowIndex","visualColumnIndex","cellMeta","getCellMeta","readOnly","className","toVisualRow","toVisualColumn","render","reverseRowOffset","reverseColOffset","visualEndpointRowIndex","getVisualRowIndex","countCols","throwOutOfBoundsWarning","roundFloat","isNaN","result","toFixed","row","runHooks","getVisualColumnIndex","column"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.number.to-fixed\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { arrayEach } from '../../helpers/array';\nimport { warn } from '../../helpers/console';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Class used to make all endpoint-related operations.\n *\n * @class Endpoints\n * @plugin ColumnSummary\n */\n\nvar Endpoints =\n/*#__PURE__*/\nfunction () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {Object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {Object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {Object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n    /**\n     * A `recordTranslator` instance.\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {Number} index Index of the endpoint.\n   * @returns {Object}\n   */\n\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     */\n\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n\n      var endpointsArray = [];\n      var settingsArray = settings;\n\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {Object} settings Object with the settings.\n     * @param {Object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {String} name Settings name.\n     * @param defaultValue Default value for the settings.\n     */\n\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     */\n\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * afterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {String} [source] Source of change.\n     * @param {Boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeRenderCallback = function beforeRenderCallback() {\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\n\n          return _this2.refreshAllEndpoints();\n        };\n\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n\n          _this2.recreatePhysicalRanges(endpoint);\n\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {Object} endpoint And endpoint object.\n     */\n\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {Object} endpoint The endpoint object.\n     * @param {Number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {Number} previousPosition Previous endpoint result position.\n     * @param {Number} offset Offset generated by the alteration.\n     */\n\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {Object} endpoint An endpoint object.\n     */\n\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.recordTranslator.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.recordTranslator.toPhysicalRow(range[0]));\n        }\n\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {Object} endpoint Endpoint object.\n     * @param {Number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} endpoints Array containing the endpoints.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints(endpoints) {\n      var _this4 = this;\n\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var endpointsArray = endpoints;\n      this.cellsToSetCache = [];\n\n      if (!endpointsArray) {\n        endpointsArray = this.getAllEndpoints();\n      }\n\n      arrayEach(endpointsArray, function (value) {\n        _this4.resetEndpointValue(value, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n\n        _this5.plugin.calculate(value);\n\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     */\n\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n\n      var _this$recordTranslato = this.recordTranslator.toVisual(endpoint.destinationRow, endpoint.destinationColumn),\n          _this$recordTranslato2 = _slicedToArray(_this$recordTranslato, 2),\n          visualRowIndex = _this$recordTranslato2[0],\n          visualColumnIndex = _this$recordTranslato2[1]; // Clear the meta on the \"old\" indexes\n\n\n      var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n      cellMeta.readOnly = false;\n      cellMeta.className = '';\n      this.cellsToSetCache.push([this.recordTranslator.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.recordTranslator.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {String} [source] Source of the call information.\n     * @param {Boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.getVisualRowIndex(endpoint.destinationRow);\n      var cellMeta = this.hot.getCellMeta(this.getVisualRowIndex(endpoint.destinationRow + reverseRowOffset), endpoint.destinationColumn + reverseColOffset);\n\n      if (visualEndpointRowIndex > this.hot.countRows() || endpoint.destinationColumn > this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Get the visual row index for the provided row. Uses the `umodifyRow` hook.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualRowIndex\",\n    value: function getVisualRowIndex(row) {\n      return this.hot.runHooks('unmodifyRow', row, 'columnSummary');\n    }\n    /**\n     * Get the visual column index for the provided column. Uses the `umodifyColumn` hook.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualColumnIndex\",\n    value: function getVisualColumnIndex(column) {\n      return this.hot.runHooks('unmodifyCol', column, 'columnSummary');\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the  Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n\n  return Endpoints;\n}();\n\nexport default Endpoints;"]},"metadata":{},"sourceType":"module"}