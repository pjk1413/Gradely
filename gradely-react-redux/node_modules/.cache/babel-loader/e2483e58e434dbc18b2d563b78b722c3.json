{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { mixin } from './../helpers/object';\nimport localHooks from './../mixins/localHooks';\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable.\n *\n * Transformation is always applied relative to the current selection.\n *\n * @class Transformation\n * @util\n */\n\nvar Transformation = /*#__PURE__*/function () {\n  function Transformation(range, options) {\n    _classCallCheck(this, Transformation);\n    /**\n     * Instance of the SelectionRange, holder for coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n\n\n    this.range = range;\n    /**\n     * Additional options which define the state of the settings which can infer transformation.\n     *\n     * @type {Object}\n     */\n\n    this.options = options;\n  }\n  /**\n   * Selects cell relative to current cell (if possible).\n   *\n   * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords}\n   */\n\n\n  _createClass(Transformation, [{\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      this.runLocalHooks('beforeTransformStart', delta);\n      var totalRows = this.options.countRows();\n      var totalCols = this.options.countCols();\n      var fixedRowsBottom = this.options.fixedRowsBottom();\n      var minSpareRows = this.options.minSpareRows();\n      var minSpareCols = this.options.minSpareCols();\n      var autoWrapRow = this.options.autoWrapRow();\n      var autoWrapCol = this.options.autoWrapCol();\n      var highlightCoords = this.range.current().highlight;\n\n      if (highlightCoords.row + rowDelta > totalRows - 1) {\n        if (force && minSpareRows > 0 && !(fixedRowsBottom && highlightCoords.row >= totalRows - fixedRowsBottom - 1)) {\n          this.runLocalHooks('insertRowRequire', totalRows);\n          totalRows = this.options.countRows();\n        } else if (autoWrapCol) {\n          delta.row = 1 - totalRows;\n          delta.col = highlightCoords.col + delta.col === totalCols - 1 ? 1 - totalCols : 1;\n        }\n      } else if (autoWrapCol && highlightCoords.row + delta.row < 0 && highlightCoords.col + delta.col >= 0) {\n        delta.row = totalRows - 1;\n        delta.col = highlightCoords.col + delta.col === 0 ? totalCols - 1 : -1;\n      }\n\n      if (highlightCoords.col + delta.col > totalCols - 1) {\n        if (force && minSpareCols > 0) {\n          this.runLocalHooks('insertColRequire', totalCols);\n          totalCols = this.options.countCols();\n        } else if (autoWrapRow) {\n          delta.row = highlightCoords.row + delta.row === totalRows - 1 ? 1 - totalRows : 1;\n          delta.col = 1 - totalCols;\n        }\n      } else if (autoWrapRow && highlightCoords.col + delta.col < 0 && highlightCoords.row + delta.row >= 0) {\n        delta.row = highlightCoords.row + delta.row === 0 ? totalRows - 1 : -1;\n        delta.col = totalCols - 1;\n      }\n\n      var coords = new CellCoords(highlightCoords.row + delta.row, highlightCoords.col + delta.col);\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n\n      if (coords.row < 0) {\n        rowTransformDir = -1;\n        coords.row = 0;\n      } else if (coords.row > 0 && coords.row >= totalRows) {\n        rowTransformDir = 1;\n        coords.row = totalRows - 1;\n      }\n\n      if (coords.col < 0) {\n        colTransformDir = -1;\n        coords.col = 0;\n      } else if (coords.col > 0 && coords.col >= totalCols) {\n        colTransformDir = 1;\n        coords.col = totalCols - 1;\n      }\n\n      this.runLocalHooks('afterTransformStart', coords, rowTransformDir, colTransformDir);\n      return coords;\n    }\n    /**\n     * Sets selection end cell relative to current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      this.runLocalHooks('beforeTransformEnd', delta);\n      var totalRows = this.options.countRows();\n      var totalCols = this.options.countCols();\n      var cellRange = this.range.current();\n      var coords = new CellCoords(cellRange.to.row + delta.row, cellRange.to.col + delta.col);\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n\n      if (coords.row < 0) {\n        rowTransformDir = -1;\n        coords.row = 0;\n      } else if (coords.row > 0 && coords.row >= totalRows) {\n        rowTransformDir = 1;\n        coords.row = totalRows - 1;\n      }\n\n      if (coords.col < 0) {\n        colTransformDir = -1;\n        coords.col = 0;\n      } else if (coords.col > 0 && coords.col >= totalCols) {\n        colTransformDir = 1;\n        coords.col = totalCols - 1;\n      }\n\n      this.runLocalHooks('afterTransformEnd', coords, rowTransformDir, colTransformDir);\n      return coords;\n    }\n  }]);\n\n  return Transformation;\n}();\n\nmixin(Transformation, localHooks);\nexport default Transformation;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/selection/transformation.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","mixin","localHooks","Transformation","range","options","value","transformStart","rowDelta","colDelta","force","delta","runLocalHooks","totalRows","countRows","totalCols","countCols","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","highlightCoords","current","highlight","row","col","coords","rowTransformDir","colTransformDir","transformEnd","cellRange","to"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { mixin } from './../helpers/object';\nimport localHooks from './../mixins/localHooks';\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable.\n *\n * Transformation is always applied relative to the current selection.\n *\n * @class Transformation\n * @util\n */\n\nvar Transformation =\n/*#__PURE__*/\nfunction () {\n  function Transformation(range, options) {\n    _classCallCheck(this, Transformation);\n\n    /**\n     * Instance of the SelectionRange, holder for coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    this.range = range;\n    /**\n     * Additional options which define the state of the settings which can infer transformation.\n     *\n     * @type {Object}\n     */\n\n    this.options = options;\n  }\n  /**\n   * Selects cell relative to current cell (if possible).\n   *\n   * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords}\n   */\n\n\n  _createClass(Transformation, [{\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      this.runLocalHooks('beforeTransformStart', delta);\n      var totalRows = this.options.countRows();\n      var totalCols = this.options.countCols();\n      var fixedRowsBottom = this.options.fixedRowsBottom();\n      var minSpareRows = this.options.minSpareRows();\n      var minSpareCols = this.options.minSpareCols();\n      var autoWrapRow = this.options.autoWrapRow();\n      var autoWrapCol = this.options.autoWrapCol();\n      var highlightCoords = this.range.current().highlight;\n\n      if (highlightCoords.row + rowDelta > totalRows - 1) {\n        if (force && minSpareRows > 0 && !(fixedRowsBottom && highlightCoords.row >= totalRows - fixedRowsBottom - 1)) {\n          this.runLocalHooks('insertRowRequire', totalRows);\n          totalRows = this.options.countRows();\n        } else if (autoWrapCol) {\n          delta.row = 1 - totalRows;\n          delta.col = highlightCoords.col + delta.col === totalCols - 1 ? 1 - totalCols : 1;\n        }\n      } else if (autoWrapCol && highlightCoords.row + delta.row < 0 && highlightCoords.col + delta.col >= 0) {\n        delta.row = totalRows - 1;\n        delta.col = highlightCoords.col + delta.col === 0 ? totalCols - 1 : -1;\n      }\n\n      if (highlightCoords.col + delta.col > totalCols - 1) {\n        if (force && minSpareCols > 0) {\n          this.runLocalHooks('insertColRequire', totalCols);\n          totalCols = this.options.countCols();\n        } else if (autoWrapRow) {\n          delta.row = highlightCoords.row + delta.row === totalRows - 1 ? 1 - totalRows : 1;\n          delta.col = 1 - totalCols;\n        }\n      } else if (autoWrapRow && highlightCoords.col + delta.col < 0 && highlightCoords.row + delta.row >= 0) {\n        delta.row = highlightCoords.row + delta.row === 0 ? totalRows - 1 : -1;\n        delta.col = totalCols - 1;\n      }\n\n      var coords = new CellCoords(highlightCoords.row + delta.row, highlightCoords.col + delta.col);\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n\n      if (coords.row < 0) {\n        rowTransformDir = -1;\n        coords.row = 0;\n      } else if (coords.row > 0 && coords.row >= totalRows) {\n        rowTransformDir = 1;\n        coords.row = totalRows - 1;\n      }\n\n      if (coords.col < 0) {\n        colTransformDir = -1;\n        coords.col = 0;\n      } else if (coords.col > 0 && coords.col >= totalCols) {\n        colTransformDir = 1;\n        coords.col = totalCols - 1;\n      }\n\n      this.runLocalHooks('afterTransformStart', coords, rowTransformDir, colTransformDir);\n      return coords;\n    }\n    /**\n     * Sets selection end cell relative to current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      var delta = new CellCoords(rowDelta, colDelta);\n      this.runLocalHooks('beforeTransformEnd', delta);\n      var totalRows = this.options.countRows();\n      var totalCols = this.options.countCols();\n      var cellRange = this.range.current();\n      var coords = new CellCoords(cellRange.to.row + delta.row, cellRange.to.col + delta.col);\n      var rowTransformDir = 0;\n      var colTransformDir = 0;\n\n      if (coords.row < 0) {\n        rowTransformDir = -1;\n        coords.row = 0;\n      } else if (coords.row > 0 && coords.row >= totalRows) {\n        rowTransformDir = 1;\n        coords.row = totalRows - 1;\n      }\n\n      if (coords.col < 0) {\n        colTransformDir = -1;\n        coords.col = 0;\n      } else if (coords.col > 0 && coords.col >= totalCols) {\n        colTransformDir = 1;\n        coords.col = totalCols - 1;\n      }\n\n      this.runLocalHooks('afterTransformEnd', coords, rowTransformDir, colTransformDir);\n      return coords;\n    }\n  }]);\n\n  return Transformation;\n}();\n\nmixin(Transformation, localHooks);\nexport default Transformation;"]},"metadata":{},"sourceType":"module"}