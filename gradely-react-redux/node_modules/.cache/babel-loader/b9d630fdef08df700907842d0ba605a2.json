{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { offset, outerHeight, outerWidth } from './../../helpers/dom/element';\nimport { arrayEach } from './../../helpers/array';\nimport { rangeEach } from './../../helpers/number';\nimport EventManager from './../../eventManager';\nimport { registerPlugin } from './../../plugins';\nimport { CellCoords } from './../../3rdparty/walkontable/src';\nimport { getDeltas, getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from './utils';\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nvar INSERT_ROW_ALTER_ACTION_NAME = 'insert_row';\nvar INTERVAL_FOR_ADDING_ROW = 200;\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\n\nvar Autofill = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Autofill, _BasePlugin);\n\n  function Autofill(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, Autofill);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Autofill).call(this, hotInstance));\n    /**\n     * Event manager instance.\n     *\n     * @private\n     * @type {EventManager}\n     */\n\n    _this.eventManager = new EventManager(_assertThisInitialized(_this));\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.addingStarted = false;\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.mouseDownOnCellCorner = false;\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.mouseDragOutside = false;\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.handleDraggedCells = 0;\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {String[]}\n     */\n\n    _this.directions = [];\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @type {Boolean}\n     */\n\n    _this.autoInsertRow = false;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Autofill, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.hot.getSettings().fillHandle;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mapSettings();\n      this.registerEvents();\n      this.addHook('afterOnCellCornerMouseDown', function (event) {\n        return _this2.onAfterCellCornerMouseDown(event);\n      });\n      this.addHook('afterOnCellCornerDblClick', function (event) {\n        return _this2.onCellCornerDblClick(event);\n      });\n      this.addHook('beforeOnCellMouseOver', function (event, coords) {\n        return _this2.onBeforeCellMouseOver(coords);\n      });\n\n      _get(_getPrototypeOf(Autofill.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      this.disablePlugin();\n      this.enablePlugin();\n\n      _get(_getPrototypeOf(Autofill.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearMappedSettings();\n\n      _get(_getPrototypeOf(Autofill.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Prepares copyable ranges from the cells selection.\n     *\n     * @private\n     * @returns {Object[]} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n     */\n\n  }, {\n    key: \"getCopyableRanges\",\n    value: function getCopyableRanges() {\n      var selRange = this.hot.getSelectedRangeLast();\n      var topLeft = selRange.getTopLeftCorner();\n      var bottomRight = selRange.getBottomRightCorner();\n      var startRow = topLeft.row;\n      var startCol = topLeft.col;\n      var endRow = bottomRight.row;\n      var endCol = bottomRight.col;\n      var copyableRanges = [];\n      copyableRanges.push({\n        startRow: startRow,\n        startCol: startCol,\n        endRow: endRow,\n        endCol: endCol\n      });\n      copyableRanges = this.hot.runHooks('modifyCopyableRange', copyableRanges);\n      return copyableRanges;\n    }\n    /**\n     * Gets selection data\n     *\n     * @private\n     * @returns {Array} Array with the data.\n     */\n\n  }, {\n    key: \"getSelectionData\",\n    value: function getSelectionData() {\n      var _this3 = this;\n\n      var copyableRanges = this.getCopyableRanges();\n      var copyableRows = [];\n      var copyableColumns = [];\n      var data = [];\n      arrayEach(copyableRanges, function (range) {\n        rangeEach(range.startRow, range.endRow, function (row) {\n          if (copyableRows.indexOf(row) === -1) {\n            copyableRows.push(row);\n          }\n        });\n        rangeEach(range.startCol, range.endCol, function (column) {\n          if (copyableColumns.indexOf(column) === -1) {\n            copyableColumns.push(column);\n          }\n        });\n      });\n      arrayEach(copyableRows, function (row) {\n        var rowSet = [];\n        arrayEach(copyableColumns, function (column) {\n          rowSet.push(_this3.hot.getCopyableData(row, column));\n        });\n        data.push(rowSet);\n      });\n      return data;\n    }\n    /**\n     * Try to apply fill values to the area in fill border, omitting the selection border.\n     *\n     * @private\n     * @returns {Boolean} reports if fill was applied.\n     *\n     * @fires Hooks#modifyAutofillRange\n     * @fires Hooks#beforeAutofill\n     */\n\n  }, {\n    key: \"fillIn\",\n    value: function fillIn() {\n      if (this.hot.selection.highlight.getFill().isEmpty()) {\n        return false;\n      }\n\n      var cornersOfSelectionAndDragAreas = this.hot.selection.highlight.getFill().getCorners();\n      this.resetSelectionOfDraggedArea();\n      var cornersOfSelectedCells = this.getCornersOfSelectedCells();\n      cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', cornersOfSelectionAndDragAreas, cornersOfSelectedCells);\n\n      var _getDragDirectionAndR = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas),\n          directionOfDrag = _getDragDirectionAndR.directionOfDrag,\n          startOfDragCoords = _getDragDirectionAndR.startOfDragCoords,\n          endOfDragCoords = _getDragDirectionAndR.endOfDragCoords;\n\n      if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n        var selectionData = this.getSelectionData();\n        this.hot.runHooks('beforeAutofill', startOfDragCoords, endOfDragCoords, selectionData);\n        var deltas = getDeltas(startOfDragCoords, endOfDragCoords, selectionData, directionOfDrag);\n        var fillData = selectionData;\n\n        if (['up', 'left'].indexOf(directionOfDrag) > -1) {\n          fillData = [];\n          var dragLength = null;\n          var fillOffset = null;\n\n          if (directionOfDrag === 'up') {\n            dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n            fillOffset = dragLength % selectionData.length;\n\n            for (var i = 0; i < dragLength; i++) {\n              fillData.push(selectionData[(i + (selectionData.length - fillOffset)) % selectionData.length]);\n            }\n          } else {\n            dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n            fillOffset = dragLength % selectionData[0].length;\n\n            for (var _i = 0; _i < selectionData.length; _i++) {\n              fillData.push([]);\n\n              for (var j = 0; j < dragLength; j++) {\n                fillData[_i].push(selectionData[_i][(j + (selectionData[_i].length - fillOffset)) % selectionData[_i].length]);\n              }\n            }\n          }\n        }\n\n        this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, \"\".concat(this.pluginName, \".fill\"), null, directionOfDrag, deltas);\n        this.setSelection(cornersOfSelectionAndDragAreas);\n      } else {\n        // reset to avoid some range bug\n        this.hot._refreshBorders();\n      }\n\n      return true;\n    }\n    /**\n     * Reduces the selection area if the handle was dragged outside of the table or on headers.\n     *\n     * @private\n     * @param {CellCoords} coords indexes of selection corners.\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"reduceSelectionAreaIfNeeded\",\n    value: function reduceSelectionAreaIfNeeded(coords) {\n      if (coords.row < 0) {\n        coords.row = 0;\n      }\n\n      if (coords.col < 0) {\n        coords.col = 0;\n      }\n\n      return coords;\n    }\n    /**\n     * Gets the coordinates of the drag & drop borders.\n     *\n     * @private\n     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCoordsOfDragAndDropBorders\",\n    value: function getCoordsOfDragAndDropBorders(coordsOfSelection) {\n      var topLeftCorner = this.hot.getSelectedRangeLast().getTopLeftCorner();\n      var bottomRightCorner = this.hot.getSelectedRangeLast().getBottomRightCorner();\n      var coords;\n\n      if (this.directions.includes(DIRECTIONS.vertical) && (bottomRightCorner.row < coordsOfSelection.row || topLeftCorner.row > coordsOfSelection.row)) {\n        coords = new CellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n        coords = new CellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      } else {\n        // wrong direction\n        return;\n      }\n\n      return this.reduceSelectionAreaIfNeeded(coords);\n    }\n    /**\n     * Show the fill border.\n     *\n     * @private\n     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"showBorder\",\n    value: function showBorder(coordsOfSelection) {\n      var coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n\n      if (coordsOfDragAndDropBorders) {\n        this.redrawBorders(coordsOfDragAndDropBorders);\n      }\n    }\n    /**\n     * Add new row\n     *\n     * @private\n     */\n\n  }, {\n    key: \"addRow\",\n    value: function addRow() {\n      var _this4 = this;\n\n      this.hot._registerTimeout(setTimeout(function () {\n        _this4.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, \"\".concat(_this4.pluginName, \".fill\"));\n\n        _this4.addingStarted = false;\n      }, INTERVAL_FOR_ADDING_ROW));\n    }\n    /**\n     * Add new rows if they are needed to continue auto-filling values.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"addNewRowIfNeeded\",\n    value: function addNewRowIfNeeded() {\n      if (this.hot.selection.highlight.getFill().cellRange && this.addingStarted === false && this.autoInsertRow) {\n        var cornersOfSelectedCells = this.hot.getSelectedLast();\n        var cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getCorners();\n        var nrOfTableRows = this.hot.countRows();\n\n        if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n          this.addingStarted = true;\n          this.addRow();\n        }\n      }\n    }\n    /**\n     * Get corners of selected cells.\n     *\n     * @private\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCornersOfSelectedCells\",\n    value: function getCornersOfSelectedCells() {\n      if (this.hot.selection.isMultiple()) {\n        return this.hot.selection.highlight.createOrGetArea().getCorners();\n      }\n\n      return this.hot.selection.highlight.getCell().getCorners();\n    }\n    /**\n     * Get index of last adjacent filled in row\n     *\n     * @private\n     * @param {Array} cornersOfSelectedCells indexes of selection corners.\n     * @returns {Number} gives number greater than or equal to zero when selection adjacent can be applied.\n     * or -1 when selection adjacent can't be applied\n     */\n\n  }, {\n    key: \"getIndexOfLastAdjacentFilledInRow\",\n    value: function getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n      var data = this.hot.getData();\n      var nrOfTableRows = this.hot.countRows();\n      var lastFilledInRowIndex;\n\n      for (var rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n        for (var columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n          var dataInCell = data[rowIndex][columnIndex];\n\n          if (dataInCell) {\n            return -1;\n          }\n        }\n\n        var dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n        var dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n\n        if (!!dataInNextLeftCell || !!dataInNextRightCell) {\n          lastFilledInRowIndex = rowIndex;\n        }\n      }\n\n      return lastFilledInRowIndex;\n    }\n    /**\n     * Adds a selection from the start area to the specific row index.\n     *\n     * @private\n     * @param {Array} selectStartArea selection area from which we start to create more comprehensive selection.\n     * @param {Number} rowIndex\n     */\n\n  }, {\n    key: \"addSelectionFromStartAreaToSpecificRowIndex\",\n    value: function addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n      this.hot.selection.highlight.getFill().clear().add(new CellCoords(selectStartArea[0], selectStartArea[1])).add(new CellCoords(rowIndex, selectStartArea[3]));\n    }\n    /**\n     * Sets selection based on passed corners.\n     *\n     * @private\n     * @param {Array} cornersOfArea\n     */\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(cornersOfArea) {\n      var _this$hot;\n\n      (_this$hot = this.hot).selectCell.apply(_this$hot, _toConsumableArray(cornersOfArea).concat([false, false]));\n    }\n    /**\n     * Try to select cells down to the last row in the left column and then returns if selection was applied.\n     *\n     * @private\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"selectAdjacent\",\n    value: function selectAdjacent() {\n      var cornersOfSelectedCells = this.getCornersOfSelectedCells();\n      var lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n\n      if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {\n        return false;\n      }\n\n      this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n      return true;\n    }\n    /**\n     * Resets selection of dragged area.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"resetSelectionOfDraggedArea\",\n    value: function resetSelectionOfDraggedArea() {\n      this.handleDraggedCells = 0;\n      this.hot.selection.highlight.getFill().clear();\n    }\n    /**\n     * Redraws borders.\n     *\n     * @private\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"redrawBorders\",\n    value: function redrawBorders(coords) {\n      this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords);\n      this.hot.view.render();\n    }\n    /**\n     * Get if mouse was dragged outside.\n     *\n     * @private\n     * @param {MouseEvent} event `mousemove` event properties.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"getIfMouseWasDraggedOutside\",\n    value: function getIfMouseWasDraggedOutside(event) {\n      var documentElement = this.hot.rootDocument.documentElement;\n      var tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n      var tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n      return event.clientY > tableBottom && event.clientX <= tableRight;\n    }\n    /**\n     * Bind the events used by the plugin.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"registerEvents\",\n    value: function registerEvents() {\n      var _this5 = this;\n\n      var documentElement = this.hot.rootDocument.documentElement;\n      this.eventManager.addEventListener(documentElement, 'mouseup', function () {\n        return _this5.onMouseUp();\n      });\n      this.eventManager.addEventListener(documentElement, 'mousemove', function (event) {\n        return _this5.onMouseMove(event);\n      });\n    }\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onCellCornerDblClick\",\n    value: function onCellCornerDblClick() {\n      var selectionApplied = this.selectAdjacent();\n\n      if (selectionApplied) {\n        this.fillIn();\n      }\n    }\n    /**\n     * On after cell corner mouse down listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterCellCornerMouseDown\",\n    value: function onAfterCellCornerMouseDown() {\n      this.handleDraggedCells = 1;\n      this.mouseDownOnCellCorner = true;\n    }\n    /**\n     * On before cell mouse over listener.\n     *\n     * @private\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"onBeforeCellMouseOver\",\n    value: function onBeforeCellMouseOver(coords) {\n      if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n        this.handleDraggedCells += 1;\n        this.showBorder(coords);\n        this.addNewRowIfNeeded();\n      }\n    }\n    /**\n     * On mouse up listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (this.handleDraggedCells) {\n        if (this.handleDraggedCells > 1) {\n          this.fillIn();\n        }\n\n        this.handleDraggedCells = 0;\n        this.mouseDownOnCellCorner = false;\n      }\n    }\n    /**\n     * On mouse move listener.\n     *\n     * @private\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n\n      if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n        this.mouseDragOutside = true;\n        this.addingStarted = true;\n      } else {\n        this.mouseDragOutside = false;\n      }\n\n      if (this.mouseDragOutside && this.autoInsertRow) {\n        this.addRow();\n      }\n    }\n    /**\n     * Clears mapped settings.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"clearMappedSettings\",\n    value: function clearMappedSettings() {\n      this.directions.length = 0;\n      this.autoInsertRow = false;\n    }\n    /**\n     * Map settings.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"mapSettings\",\n    value: function mapSettings() {\n      var mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n      this.directions = mappedSettings.directions;\n      this.autoInsertRow = mappedSettings.autoInsertRow;\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Autofill.prototype), \"destroy\", this).call(this);\n    }\n  }]);\n\n  return Autofill;\n}(BasePlugin);\n\nregisterPlugin('autofill', Autofill);\nexport default Autofill;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/plugins/autofill/autofill.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Object","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","value","object","hasOwnProperty","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","BasePlugin","Hooks","offset","outerHeight","outerWidth","arrayEach","rangeEach","EventManager","registerPlugin","CellCoords","getDeltas","getDragDirectionAndRange","DIRECTIONS","getMappedFillHandleSetting","getSingleton","register","INSERT_ROW_ALTER_ACTION_NAME","INTERVAL_FOR_ADDING_ROW","Autofill","_BasePlugin","hotInstance","_this","eventManager","addingStarted","mouseDownOnCellCorner","mouseDragOutside","handleDraggedCells","directions","autoInsertRow","isEnabled","hot","getSettings","fillHandle","enablePlugin","_this2","enabled","mapSettings","registerEvents","addHook","event","onAfterCellCornerMouseDown","onCellCornerDblClick","coords","onBeforeCellMouseOver","updatePlugin","disablePlugin","clearMappedSettings","getCopyableRanges","selRange","getSelectedRangeLast","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","startRow","row","startCol","col","endRow","endCol","copyableRanges","push","runHooks","getSelectionData","_this3","copyableRows","copyableColumns","data","range","indexOf","column","rowSet","getCopyableData","fillIn","selection","highlight","getFill","isEmpty","cornersOfSelectionAndDragAreas","getCorners","resetSelectionOfDraggedArea","cornersOfSelectedCells","getCornersOfSelectedCells","_getDragDirectionAndR","directionOfDrag","startOfDragCoords","endOfDragCoords","selectionData","deltas","fillData","dragLength","fillOffset","_i","j","populateFromArray","concat","pluginName","setSelection","_refreshBorders","reduceSelectionAreaIfNeeded","getCoordsOfDragAndDropBorders","coordsOfSelection","topLeftCorner","bottomRightCorner","includes","vertical","horizontal","showBorder","coordsOfDragAndDropBorders","redrawBorders","addRow","_this4","_registerTimeout","setTimeout","alter","addNewRowIfNeeded","cellRange","getSelectedLast","cornersOfSelectedDragArea","nrOfTableRows","countRows","isMultiple","createOrGetArea","getCell","getIndexOfLastAdjacentFilledInRow","getData","lastFilledInRowIndex","rowIndex","columnIndex","dataInCell","dataInNextLeftCell","dataInNextRightCell","addSelectionFromStartAreaToSpecificRowIndex","selectStartArea","clear","add","cornersOfArea","_this$hot","selectCell","apply","selectAdjacent","to","view","render","getIfMouseWasDraggedOutside","documentElement","rootDocument","tableBottom","table","top","rootWindow","pageYOffset","scrollTop","tableRight","left","pageXOffset","scrollLeft","clientY","clientX","_this5","addEventListener","onMouseUp","onMouseMove","selectionApplied","isMouseDown","mouseWasDraggedOutside","mappedSettings","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.get-own-property-descriptor\";\nimport \"core-js/modules/es.object.get-prototype-of\";\nimport \"core-js/modules/es.object.set-prototype-of\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.reflect.get\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nimport \"core-js/modules/web.timers\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { offset, outerHeight, outerWidth } from './../../helpers/dom/element';\nimport { arrayEach } from './../../helpers/array';\nimport { rangeEach } from './../../helpers/number';\nimport EventManager from './../../eventManager';\nimport { registerPlugin } from './../../plugins';\nimport { CellCoords } from './../../3rdparty/walkontable/src';\nimport { getDeltas, getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from './utils';\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nvar INSERT_ROW_ALTER_ACTION_NAME = 'insert_row';\nvar INTERVAL_FOR_ADDING_ROW = 200;\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\n\nvar Autofill =\n/*#__PURE__*/\nfunction (_BasePlugin) {\n  _inherits(Autofill, _BasePlugin);\n\n  function Autofill(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, Autofill);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Autofill).call(this, hotInstance));\n    /**\n     * Event manager instance.\n     *\n     * @private\n     * @type {EventManager}\n     */\n\n    _this.eventManager = new EventManager(_assertThisInitialized(_this));\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.addingStarted = false;\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.mouseDownOnCellCorner = false;\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.mouseDragOutside = false;\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this.handleDraggedCells = 0;\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {String[]}\n     */\n\n    _this.directions = [];\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @type {Boolean}\n     */\n\n    _this.autoInsertRow = false;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Autofill, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.hot.getSettings().fillHandle;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mapSettings();\n      this.registerEvents();\n      this.addHook('afterOnCellCornerMouseDown', function (event) {\n        return _this2.onAfterCellCornerMouseDown(event);\n      });\n      this.addHook('afterOnCellCornerDblClick', function (event) {\n        return _this2.onCellCornerDblClick(event);\n      });\n      this.addHook('beforeOnCellMouseOver', function (event, coords) {\n        return _this2.onBeforeCellMouseOver(coords);\n      });\n\n      _get(_getPrototypeOf(Autofill.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      this.disablePlugin();\n      this.enablePlugin();\n\n      _get(_getPrototypeOf(Autofill.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearMappedSettings();\n\n      _get(_getPrototypeOf(Autofill.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Prepares copyable ranges from the cells selection.\n     *\n     * @private\n     * @returns {Object[]} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n     */\n\n  }, {\n    key: \"getCopyableRanges\",\n    value: function getCopyableRanges() {\n      var selRange = this.hot.getSelectedRangeLast();\n      var topLeft = selRange.getTopLeftCorner();\n      var bottomRight = selRange.getBottomRightCorner();\n      var startRow = topLeft.row;\n      var startCol = topLeft.col;\n      var endRow = bottomRight.row;\n      var endCol = bottomRight.col;\n      var copyableRanges = [];\n      copyableRanges.push({\n        startRow: startRow,\n        startCol: startCol,\n        endRow: endRow,\n        endCol: endCol\n      });\n      copyableRanges = this.hot.runHooks('modifyCopyableRange', copyableRanges);\n      return copyableRanges;\n    }\n    /**\n     * Gets selection data\n     *\n     * @private\n     * @returns {Array} Array with the data.\n     */\n\n  }, {\n    key: \"getSelectionData\",\n    value: function getSelectionData() {\n      var _this3 = this;\n\n      var copyableRanges = this.getCopyableRanges();\n      var copyableRows = [];\n      var copyableColumns = [];\n      var data = [];\n      arrayEach(copyableRanges, function (range) {\n        rangeEach(range.startRow, range.endRow, function (row) {\n          if (copyableRows.indexOf(row) === -1) {\n            copyableRows.push(row);\n          }\n        });\n        rangeEach(range.startCol, range.endCol, function (column) {\n          if (copyableColumns.indexOf(column) === -1) {\n            copyableColumns.push(column);\n          }\n        });\n      });\n      arrayEach(copyableRows, function (row) {\n        var rowSet = [];\n        arrayEach(copyableColumns, function (column) {\n          rowSet.push(_this3.hot.getCopyableData(row, column));\n        });\n        data.push(rowSet);\n      });\n      return data;\n    }\n    /**\n     * Try to apply fill values to the area in fill border, omitting the selection border.\n     *\n     * @private\n     * @returns {Boolean} reports if fill was applied.\n     *\n     * @fires Hooks#modifyAutofillRange\n     * @fires Hooks#beforeAutofill\n     */\n\n  }, {\n    key: \"fillIn\",\n    value: function fillIn() {\n      if (this.hot.selection.highlight.getFill().isEmpty()) {\n        return false;\n      }\n\n      var cornersOfSelectionAndDragAreas = this.hot.selection.highlight.getFill().getCorners();\n      this.resetSelectionOfDraggedArea();\n      var cornersOfSelectedCells = this.getCornersOfSelectedCells();\n      cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', cornersOfSelectionAndDragAreas, cornersOfSelectedCells);\n\n      var _getDragDirectionAndR = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas),\n          directionOfDrag = _getDragDirectionAndR.directionOfDrag,\n          startOfDragCoords = _getDragDirectionAndR.startOfDragCoords,\n          endOfDragCoords = _getDragDirectionAndR.endOfDragCoords;\n\n      if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n        var selectionData = this.getSelectionData();\n        this.hot.runHooks('beforeAutofill', startOfDragCoords, endOfDragCoords, selectionData);\n        var deltas = getDeltas(startOfDragCoords, endOfDragCoords, selectionData, directionOfDrag);\n        var fillData = selectionData;\n\n        if (['up', 'left'].indexOf(directionOfDrag) > -1) {\n          fillData = [];\n          var dragLength = null;\n          var fillOffset = null;\n\n          if (directionOfDrag === 'up') {\n            dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n            fillOffset = dragLength % selectionData.length;\n\n            for (var i = 0; i < dragLength; i++) {\n              fillData.push(selectionData[(i + (selectionData.length - fillOffset)) % selectionData.length]);\n            }\n          } else {\n            dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n            fillOffset = dragLength % selectionData[0].length;\n\n            for (var _i = 0; _i < selectionData.length; _i++) {\n              fillData.push([]);\n\n              for (var j = 0; j < dragLength; j++) {\n                fillData[_i].push(selectionData[_i][(j + (selectionData[_i].length - fillOffset)) % selectionData[_i].length]);\n              }\n            }\n          }\n        }\n\n        this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, \"\".concat(this.pluginName, \".fill\"), null, directionOfDrag, deltas);\n        this.setSelection(cornersOfSelectionAndDragAreas);\n      } else {\n        // reset to avoid some range bug\n        this.hot._refreshBorders();\n      }\n\n      return true;\n    }\n    /**\n     * Reduces the selection area if the handle was dragged outside of the table or on headers.\n     *\n     * @private\n     * @param {CellCoords} coords indexes of selection corners.\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"reduceSelectionAreaIfNeeded\",\n    value: function reduceSelectionAreaIfNeeded(coords) {\n      if (coords.row < 0) {\n        coords.row = 0;\n      }\n\n      if (coords.col < 0) {\n        coords.col = 0;\n      }\n\n      return coords;\n    }\n    /**\n     * Gets the coordinates of the drag & drop borders.\n     *\n     * @private\n     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCoordsOfDragAndDropBorders\",\n    value: function getCoordsOfDragAndDropBorders(coordsOfSelection) {\n      var topLeftCorner = this.hot.getSelectedRangeLast().getTopLeftCorner();\n      var bottomRightCorner = this.hot.getSelectedRangeLast().getBottomRightCorner();\n      var coords;\n\n      if (this.directions.includes(DIRECTIONS.vertical) && (bottomRightCorner.row < coordsOfSelection.row || topLeftCorner.row > coordsOfSelection.row)) {\n        coords = new CellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n        coords = new CellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      } else {\n        // wrong direction\n        return;\n      }\n\n      return this.reduceSelectionAreaIfNeeded(coords);\n    }\n    /**\n     * Show the fill border.\n     *\n     * @private\n     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"showBorder\",\n    value: function showBorder(coordsOfSelection) {\n      var coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n\n      if (coordsOfDragAndDropBorders) {\n        this.redrawBorders(coordsOfDragAndDropBorders);\n      }\n    }\n    /**\n     * Add new row\n     *\n     * @private\n     */\n\n  }, {\n    key: \"addRow\",\n    value: function addRow() {\n      var _this4 = this;\n\n      this.hot._registerTimeout(setTimeout(function () {\n        _this4.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, \"\".concat(_this4.pluginName, \".fill\"));\n\n        _this4.addingStarted = false;\n      }, INTERVAL_FOR_ADDING_ROW));\n    }\n    /**\n     * Add new rows if they are needed to continue auto-filling values.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"addNewRowIfNeeded\",\n    value: function addNewRowIfNeeded() {\n      if (this.hot.selection.highlight.getFill().cellRange && this.addingStarted === false && this.autoInsertRow) {\n        var cornersOfSelectedCells = this.hot.getSelectedLast();\n        var cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getCorners();\n        var nrOfTableRows = this.hot.countRows();\n\n        if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n          this.addingStarted = true;\n          this.addRow();\n        }\n      }\n    }\n    /**\n     * Get corners of selected cells.\n     *\n     * @private\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCornersOfSelectedCells\",\n    value: function getCornersOfSelectedCells() {\n      if (this.hot.selection.isMultiple()) {\n        return this.hot.selection.highlight.createOrGetArea().getCorners();\n      }\n\n      return this.hot.selection.highlight.getCell().getCorners();\n    }\n    /**\n     * Get index of last adjacent filled in row\n     *\n     * @private\n     * @param {Array} cornersOfSelectedCells indexes of selection corners.\n     * @returns {Number} gives number greater than or equal to zero when selection adjacent can be applied.\n     * or -1 when selection adjacent can't be applied\n     */\n\n  }, {\n    key: \"getIndexOfLastAdjacentFilledInRow\",\n    value: function getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n      var data = this.hot.getData();\n      var nrOfTableRows = this.hot.countRows();\n      var lastFilledInRowIndex;\n\n      for (var rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n        for (var columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n          var dataInCell = data[rowIndex][columnIndex];\n\n          if (dataInCell) {\n            return -1;\n          }\n        }\n\n        var dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n        var dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n\n        if (!!dataInNextLeftCell || !!dataInNextRightCell) {\n          lastFilledInRowIndex = rowIndex;\n        }\n      }\n\n      return lastFilledInRowIndex;\n    }\n    /**\n     * Adds a selection from the start area to the specific row index.\n     *\n     * @private\n     * @param {Array} selectStartArea selection area from which we start to create more comprehensive selection.\n     * @param {Number} rowIndex\n     */\n\n  }, {\n    key: \"addSelectionFromStartAreaToSpecificRowIndex\",\n    value: function addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n      this.hot.selection.highlight.getFill().clear().add(new CellCoords(selectStartArea[0], selectStartArea[1])).add(new CellCoords(rowIndex, selectStartArea[3]));\n    }\n    /**\n     * Sets selection based on passed corners.\n     *\n     * @private\n     * @param {Array} cornersOfArea\n     */\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(cornersOfArea) {\n      var _this$hot;\n\n      (_this$hot = this.hot).selectCell.apply(_this$hot, _toConsumableArray(cornersOfArea).concat([false, false]));\n    }\n    /**\n     * Try to select cells down to the last row in the left column and then returns if selection was applied.\n     *\n     * @private\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"selectAdjacent\",\n    value: function selectAdjacent() {\n      var cornersOfSelectedCells = this.getCornersOfSelectedCells();\n      var lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n\n      if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {\n        return false;\n      }\n\n      this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n      return true;\n    }\n    /**\n     * Resets selection of dragged area.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"resetSelectionOfDraggedArea\",\n    value: function resetSelectionOfDraggedArea() {\n      this.handleDraggedCells = 0;\n      this.hot.selection.highlight.getFill().clear();\n    }\n    /**\n     * Redraws borders.\n     *\n     * @private\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"redrawBorders\",\n    value: function redrawBorders(coords) {\n      this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords);\n      this.hot.view.render();\n    }\n    /**\n     * Get if mouse was dragged outside.\n     *\n     * @private\n     * @param {MouseEvent} event `mousemove` event properties.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"getIfMouseWasDraggedOutside\",\n    value: function getIfMouseWasDraggedOutside(event) {\n      var documentElement = this.hot.rootDocument.documentElement;\n      var tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n      var tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n      return event.clientY > tableBottom && event.clientX <= tableRight;\n    }\n    /**\n     * Bind the events used by the plugin.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"registerEvents\",\n    value: function registerEvents() {\n      var _this5 = this;\n\n      var documentElement = this.hot.rootDocument.documentElement;\n      this.eventManager.addEventListener(documentElement, 'mouseup', function () {\n        return _this5.onMouseUp();\n      });\n      this.eventManager.addEventListener(documentElement, 'mousemove', function (event) {\n        return _this5.onMouseMove(event);\n      });\n    }\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onCellCornerDblClick\",\n    value: function onCellCornerDblClick() {\n      var selectionApplied = this.selectAdjacent();\n\n      if (selectionApplied) {\n        this.fillIn();\n      }\n    }\n    /**\n     * On after cell corner mouse down listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterCellCornerMouseDown\",\n    value: function onAfterCellCornerMouseDown() {\n      this.handleDraggedCells = 1;\n      this.mouseDownOnCellCorner = true;\n    }\n    /**\n     * On before cell mouse over listener.\n     *\n     * @private\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n\n  }, {\n    key: \"onBeforeCellMouseOver\",\n    value: function onBeforeCellMouseOver(coords) {\n      if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n        this.handleDraggedCells += 1;\n        this.showBorder(coords);\n        this.addNewRowIfNeeded();\n      }\n    }\n    /**\n     * On mouse up listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (this.handleDraggedCells) {\n        if (this.handleDraggedCells > 1) {\n          this.fillIn();\n        }\n\n        this.handleDraggedCells = 0;\n        this.mouseDownOnCellCorner = false;\n      }\n    }\n    /**\n     * On mouse move listener.\n     *\n     * @private\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n\n      if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n        this.mouseDragOutside = true;\n        this.addingStarted = true;\n      } else {\n        this.mouseDragOutside = false;\n      }\n\n      if (this.mouseDragOutside && this.autoInsertRow) {\n        this.addRow();\n      }\n    }\n    /**\n     * Clears mapped settings.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"clearMappedSettings\",\n    value: function clearMappedSettings() {\n      this.directions.length = 0;\n      this.autoInsertRow = false;\n    }\n    /**\n     * Map settings.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"mapSettings\",\n    value: function mapSettings() {\n      var mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n      this.directions = mappedSettings.directions;\n      this.autoInsertRow = mappedSettings.autoInsertRow;\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Autofill.prototype), \"destroy\", this).call(this);\n    }\n  }]);\n\n  return Autofill;\n}(BasePlugin);\n\nregisterPlugin('autofill', Autofill);\nexport default Autofill;"]},"metadata":{},"sourceType":"module"}