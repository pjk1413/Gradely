{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport { arrayReduce, arrayMap, arrayMax } from './../helpers/array';\nimport { defineGetter } from './../helpers/object';\nimport { rangeEach } from './../helpers/number';\nvar MIXIN_NAME = 'arrayMapper';\n/**\n * @type {Object}\n */\n\nvar arrayMapper = {\n  _arrayMap: [],\n\n  /**\n   * Get translated index by its physical index.\n   *\n   * @param {Number} physicalIndex Physical index.\n   * @return {Number|null} Returns translated index mapped by passed physical index.\n   */\n  getValueByIndex: function getValueByIndex(physicalIndex) {\n    var length = this._arrayMap.length;\n    var translatedIndex = null;\n\n    if (physicalIndex < length) {\n      translatedIndex = this._arrayMap[physicalIndex];\n    }\n\n    return translatedIndex;\n  },\n\n  /**\n   * Get physical index by its translated index.\n   *\n   * @param {*} translatedIndex Value to search.\n   * @returns {Number|null} Returns a physical index of the array mapper.\n   */\n  getIndexByValue: function getIndexByValue(translatedIndex) {\n    var physicalIndex; // eslint-disable-next-line no-cond-assign, no-return-assign\n\n    return (physicalIndex = this._arrayMap.indexOf(translatedIndex)) === -1 ? null : physicalIndex;\n  },\n\n  /**\n   * Insert new items to array mapper starting at passed index. New entries will be a continuation of last value in the array.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   * @returns {Array} Returns added items.\n   */\n  insertItems: function insertItems(physicalIndex) {\n    var _this = this;\n\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var newIndex = arrayMax(this._arrayMap) + 1;\n    var addedItems = [];\n    rangeEach(amount - 1, function (count) {\n      addedItems.push(_this._arrayMap.splice(physicalIndex + count, 0, newIndex + count));\n    });\n    return addedItems;\n  },\n\n  /**\n   * Remove items from array mapper.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   * @returns {Array} Returns removed items.\n   */\n  removeItems: function removeItems(physicalIndex) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var removedItems = [];\n\n    if (Array.isArray(physicalIndex)) {\n      var mapCopy = [].concat(this._arrayMap); // Sort descending\n\n      physicalIndex.sort(function (a, b) {\n        return b - a;\n      });\n\n      for (var i = 0, length = physicalIndex.length; i < length; i++) {\n        var indexToRemove = physicalIndex[i];\n\n        this._arrayMap.splice(indexToRemove, 1);\n\n        removedItems.push(mapCopy[indexToRemove]);\n      }\n    } else {\n      removedItems = this._arrayMap.splice(physicalIndex, amount);\n    }\n\n    return removedItems;\n  },\n\n  /**\n   * Unshift items (remove and shift chunk of array to the left).\n   *\n   * @param {Number|Array} physicalIndex Array index or Array of indexes to unshift.\n   * @param {Number} [amount=1] Defines how many items will be removed from an array (when index is passed as number).\n   */\n  unshiftItems: function unshiftItems(physicalIndex) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var removedItems = this.removeItems(physicalIndex, amount);\n\n    function countRowShift(logicalRow) {\n      // Todo: compare perf between reduce vs sort->each->brake\n      return arrayReduce(removedItems, function (count, removedLogicalRow) {\n        var result = count;\n\n        if (logicalRow > removedLogicalRow) {\n          result += 1;\n        }\n\n        return result;\n      }, 0);\n    }\n\n    this._arrayMap = arrayMap(this._arrayMap, function (logicalRow) {\n      var logicalRowIndex = logicalRow;\n      var rowShift = countRowShift(logicalRowIndex);\n\n      if (rowShift) {\n        logicalRowIndex -= rowShift;\n      }\n\n      return logicalRowIndex;\n    });\n  },\n\n  /**\n   * Shift (right shifting) items starting at passed index.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   */\n  shiftItems: function shiftItems(physicalIndex) {\n    var _this2 = this;\n\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._arrayMap = arrayMap(this._arrayMap, function (row) {\n      var physicalRowIndex = row;\n\n      if (physicalRowIndex >= physicalIndex) {\n        physicalRowIndex += amount;\n      }\n\n      return physicalRowIndex;\n    });\n    rangeEach(amount - 1, function (count) {\n      _this2._arrayMap.splice(physicalIndex + count, 0, physicalIndex + count);\n    });\n  },\n\n  /**\n   * Swap indexes in arrayMapper.\n   *\n   * @param {Number} physicalIndexFrom index to move.\n   * @param {Number} physicalIndexTo index to.\n   */\n  swapIndexes: function swapIndexes(physicalIndexFrom, physicalIndexTo) {\n    var _this$_arrayMap;\n\n    (_this$_arrayMap = this._arrayMap).splice.apply(_this$_arrayMap, [physicalIndexTo, 0].concat(_toConsumableArray(this._arrayMap.splice(physicalIndexFrom, 1))));\n  },\n\n  /**\n   * Clear all stored index<->value information from an array.\n   */\n  clearMap: function clearMap() {\n    this._arrayMap.length = 0;\n  }\n};\ndefineGetter(arrayMapper, 'MIXIN_NAME', MIXIN_NAME, {\n  writable: false,\n  enumerable: false\n});\nexport default arrayMapper;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/mixins/arrayMapper.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","arrayReduce","arrayMap","arrayMax","defineGetter","rangeEach","MIXIN_NAME","arrayMapper","_arrayMap","getValueByIndex","physicalIndex","translatedIndex","getIndexByValue","indexOf","insertItems","_this","amount","arguments","undefined","newIndex","addedItems","count","push","splice","removeItems","removedItems","mapCopy","concat","sort","a","b","indexToRemove","unshiftItems","countRowShift","logicalRow","removedLogicalRow","result","logicalRowIndex","rowShift","shiftItems","_this2","row","physicalRowIndex","swapIndexes","physicalIndexFrom","physicalIndexTo","_this$_arrayMap","apply","clearMap","writable","enumerable"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport { arrayReduce, arrayMap, arrayMax } from './../helpers/array';\nimport { defineGetter } from './../helpers/object';\nimport { rangeEach } from './../helpers/number';\nvar MIXIN_NAME = 'arrayMapper';\n/**\n * @type {Object}\n */\n\nvar arrayMapper = {\n  _arrayMap: [],\n\n  /**\n   * Get translated index by its physical index.\n   *\n   * @param {Number} physicalIndex Physical index.\n   * @return {Number|null} Returns translated index mapped by passed physical index.\n   */\n  getValueByIndex: function getValueByIndex(physicalIndex) {\n    var length = this._arrayMap.length;\n    var translatedIndex = null;\n\n    if (physicalIndex < length) {\n      translatedIndex = this._arrayMap[physicalIndex];\n    }\n\n    return translatedIndex;\n  },\n\n  /**\n   * Get physical index by its translated index.\n   *\n   * @param {*} translatedIndex Value to search.\n   * @returns {Number|null} Returns a physical index of the array mapper.\n   */\n  getIndexByValue: function getIndexByValue(translatedIndex) {\n    var physicalIndex; // eslint-disable-next-line no-cond-assign, no-return-assign\n\n    return (physicalIndex = this._arrayMap.indexOf(translatedIndex)) === -1 ? null : physicalIndex;\n  },\n\n  /**\n   * Insert new items to array mapper starting at passed index. New entries will be a continuation of last value in the array.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   * @returns {Array} Returns added items.\n   */\n  insertItems: function insertItems(physicalIndex) {\n    var _this = this;\n\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var newIndex = arrayMax(this._arrayMap) + 1;\n    var addedItems = [];\n    rangeEach(amount - 1, function (count) {\n      addedItems.push(_this._arrayMap.splice(physicalIndex + count, 0, newIndex + count));\n    });\n    return addedItems;\n  },\n\n  /**\n   * Remove items from array mapper.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   * @returns {Array} Returns removed items.\n   */\n  removeItems: function removeItems(physicalIndex) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var removedItems = [];\n\n    if (Array.isArray(physicalIndex)) {\n      var mapCopy = [].concat(this._arrayMap); // Sort descending\n\n      physicalIndex.sort(function (a, b) {\n        return b - a;\n      });\n\n      for (var i = 0, length = physicalIndex.length; i < length; i++) {\n        var indexToRemove = physicalIndex[i];\n\n        this._arrayMap.splice(indexToRemove, 1);\n\n        removedItems.push(mapCopy[indexToRemove]);\n      }\n    } else {\n      removedItems = this._arrayMap.splice(physicalIndex, amount);\n    }\n\n    return removedItems;\n  },\n\n  /**\n   * Unshift items (remove and shift chunk of array to the left).\n   *\n   * @param {Number|Array} physicalIndex Array index or Array of indexes to unshift.\n   * @param {Number} [amount=1] Defines how many items will be removed from an array (when index is passed as number).\n   */\n  unshiftItems: function unshiftItems(physicalIndex) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var removedItems = this.removeItems(physicalIndex, amount);\n\n    function countRowShift(logicalRow) {\n      // Todo: compare perf between reduce vs sort->each->brake\n      return arrayReduce(removedItems, function (count, removedLogicalRow) {\n        var result = count;\n\n        if (logicalRow > removedLogicalRow) {\n          result += 1;\n        }\n\n        return result;\n      }, 0);\n    }\n\n    this._arrayMap = arrayMap(this._arrayMap, function (logicalRow) {\n      var logicalRowIndex = logicalRow;\n      var rowShift = countRowShift(logicalRowIndex);\n\n      if (rowShift) {\n        logicalRowIndex -= rowShift;\n      }\n\n      return logicalRowIndex;\n    });\n  },\n\n  /**\n   * Shift (right shifting) items starting at passed index.\n   *\n   * @param {Number} physicalIndex Array index.\n   * @param {Number} [amount=1] Defines how many items will be created to an array.\n   */\n  shiftItems: function shiftItems(physicalIndex) {\n    var _this2 = this;\n\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._arrayMap = arrayMap(this._arrayMap, function (row) {\n      var physicalRowIndex = row;\n\n      if (physicalRowIndex >= physicalIndex) {\n        physicalRowIndex += amount;\n      }\n\n      return physicalRowIndex;\n    });\n    rangeEach(amount - 1, function (count) {\n      _this2._arrayMap.splice(physicalIndex + count, 0, physicalIndex + count);\n    });\n  },\n\n  /**\n   * Swap indexes in arrayMapper.\n   *\n   * @param {Number} physicalIndexFrom index to move.\n   * @param {Number} physicalIndexTo index to.\n   */\n  swapIndexes: function swapIndexes(physicalIndexFrom, physicalIndexTo) {\n    var _this$_arrayMap;\n\n    (_this$_arrayMap = this._arrayMap).splice.apply(_this$_arrayMap, [physicalIndexTo, 0].concat(_toConsumableArray(this._arrayMap.splice(physicalIndexFrom, 1))));\n  },\n\n  /**\n   * Clear all stored index<->value information from an array.\n   */\n  clearMap: function clearMap() {\n    this._arrayMap.length = 0;\n  }\n};\ndefineGetter(arrayMapper, 'MIXIN_NAME', MIXIN_NAME, {\n  writable: false,\n  enumerable: false\n});\nexport default arrayMapper;"]},"metadata":{},"sourceType":"module"}