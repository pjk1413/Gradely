{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n/**\n * Immutable Set like interface of points\n *\n * \n */\n\nimport * as PointMap from \"./point-map\";\n/** Appends a new point to the Set object */\n\nexport var add = function add(set, point) {\n  return PointMap.set(point, true, set);\n};\n/** Removes the point from the Set object */\n\nexport var remove = function remove(set, point) {\n  return PointMap.unset(point, set);\n};\n/** Returns a boolean asserting whether an point is present with the given value in the Set object or not */\n\nexport var has = function has(set, point) {\n  return PointMap.has(point, set);\n};\n/** Returns the number of points in a PointSet object */\n\nexport var size = function size(set) {\n  return PointMap.size(set);\n};\n/** Applies a function against an accumulator and each point in the set (from left to right) to reduce it to a single value */\n\nexport function reduce(func, set, initialValue) {\n  return PointMap.reduce(function (acc, _, point) {\n    return func(acc, point);\n  }, set, initialValue);\n}\n/** Creates a new set with the results of calling a provided function on every point in the calling set */\n\nexport function map(func, set) {\n  return reduce(function (acc, point) {\n    return add(acc, func(point));\n  }, set, from([]));\n}\n/** Creates a new set with all points that pass the test implemented by the provided function */\n\nexport function filter(func, set) {\n  return PointMap.filter(function (_, point) {\n    return func(point);\n  }, set);\n}\n\nvar minKey = function minKey(object) {\n  return (// $FlowFixMe\n    Math.min.apply(Math, _toConsumableArray(Object.keys(object)))\n  );\n};\n/** Returns the point on the minimal row in the minimal column in the set */\n\n\nexport function min(set) {\n  var row = minKey(set);\n  return {\n    row: row,\n    column: minKey(set[row])\n  };\n}\n\nvar maxKey = function maxKey(object) {\n  return (// $FlowFixMe\n    Math.max.apply(Math, _toConsumableArray(Object.keys(object)))\n  );\n};\n/** Returns the point on the maximal row in the maximal column in the set */\n\n\nexport function max(set) {\n  var row = maxKey(set);\n  return {\n    row: row,\n    column: maxKey(set[row])\n  };\n}\n/** Creates a new PointSet instance from an array-like or iterable object */\n\nexport function from(points) {\n  return points.reduce(add, PointMap.from([]));\n}\n/** Returns whether set has any points in */\n\nexport var isEmpty = function isEmpty(set) {\n  return PointMap.isEmpty(set);\n};\n/** Returns an array of the set points */\n\nexport function toArray(set) {\n  return reduce(function (acc, point) {\n    return [].concat(_toConsumableArray(acc), [point]);\n  }, set, []);\n}\nvar NO_EDGE = {\n  left: false,\n  right: false,\n  top: false,\n  bottom: false\n};\nexport function onEdge(set, point) {\n  if (!has(set, point)) {\n    return NO_EDGE;\n  }\n\n  var hasNot = function hasNot(rowDelta, columnDelta) {\n    return !has(set, {\n      row: point.row + rowDelta,\n      column: point.column + columnDelta\n    });\n  };\n\n  return {\n    left: hasNot(0, -1),\n    right: hasNot(0, 1),\n    top: hasNot(-1, 0),\n    bottom: hasNot(1, 0)\n  };\n}\nexport function getEdgeValue(set, field, delta) {\n  var compare = Math.sign(delta) === -1 ? Math.min : Math.max;\n\n  if (size(set) === 0) {\n    throw new Error(\"getEdgeValue() should never be called with an empty set\");\n  } // $FlowFixMe\n\n\n  return reduce(function (acc, point) {\n    if (acc === null) {\n      return point[field];\n    }\n\n    return compare(acc, point[field]);\n  }, set, null);\n}\nexport function extendEdge(set, field, delta) {\n  var oppositeField = field === \"row\" ? \"column\" : \"row\";\n  var edgeValue = getEdgeValue(set, field, delta);\n  return reduce(function (acc, point) {\n    if (point[field] === edgeValue) {\n      var _add;\n\n      return add(acc, (_add = {}, _defineProperty(_add, field, edgeValue + delta), _defineProperty(_add, oppositeField, point[oppositeField]), _add));\n    }\n\n    return acc;\n  }, set, set);\n}\nexport function shrinkEdge(set, field, delta) {\n  var edgeValue = getEdgeValue(set, field, delta);\n  return reduce(function (acc, point) {\n    if (point[field] === edgeValue) {\n      return remove(acc, point);\n    }\n\n    return acc;\n  }, set, set);\n}","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/react-spreadsheet/dist/point-set.js"],"names":["_defineProperty","_toConsumableArray","PointMap","add","set","point","remove","unset","has","size","reduce","func","initialValue","acc","_","map","from","filter","minKey","object","Math","min","apply","Object","keys","row","column","maxKey","max","points","isEmpty","toArray","concat","NO_EDGE","left","right","top","bottom","onEdge","hasNot","rowDelta","columnDelta","getEdgeValue","field","delta","compare","sign","Error","extendEdge","oppositeField","edgeValue","_add","shrinkEdge"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * Immutable Set like interface of points\n *\n * \n */\nimport * as PointMap from \"./point-map\";\n\n/** Appends a new point to the Set object */\nexport var add = function add(set, point) {\n  return PointMap.set(point, true, set);\n};\n/** Removes the point from the Set object */\n\nexport var remove = function remove(set, point) {\n  return PointMap.unset(point, set);\n};\n/** Returns a boolean asserting whether an point is present with the given value in the Set object or not */\n\nexport var has = function has(set, point) {\n  return PointMap.has(point, set);\n};\n/** Returns the number of points in a PointSet object */\n\nexport var size = function size(set) {\n  return PointMap.size(set);\n};\n/** Applies a function against an accumulator and each point in the set (from left to right) to reduce it to a single value */\n\nexport function reduce(func, set, initialValue) {\n  return PointMap.reduce(function (acc, _, point) {\n    return func(acc, point);\n  }, set, initialValue);\n}\n/** Creates a new set with the results of calling a provided function on every point in the calling set */\n\nexport function map(func, set) {\n  return reduce(function (acc, point) {\n    return add(acc, func(point));\n  }, set, from([]));\n}\n/** Creates a new set with all points that pass the test implemented by the provided function */\n\nexport function filter(func, set) {\n  return PointMap.filter(function (_, point) {\n    return func(point);\n  }, set);\n}\n\nvar minKey = function minKey(object) {\n  return (// $FlowFixMe\n    Math.min.apply(Math, _toConsumableArray(Object.keys(object)))\n  );\n};\n/** Returns the point on the minimal row in the minimal column in the set */\n\n\nexport function min(set) {\n  var row = minKey(set);\n  return {\n    row: row,\n    column: minKey(set[row])\n  };\n}\n\nvar maxKey = function maxKey(object) {\n  return (// $FlowFixMe\n    Math.max.apply(Math, _toConsumableArray(Object.keys(object)))\n  );\n};\n/** Returns the point on the maximal row in the maximal column in the set */\n\n\nexport function max(set) {\n  var row = maxKey(set);\n  return {\n    row: row,\n    column: maxKey(set[row])\n  };\n}\n/** Creates a new PointSet instance from an array-like or iterable object */\n\nexport function from(points) {\n  return points.reduce(add, PointMap.from([]));\n}\n/** Returns whether set has any points in */\n\nexport var isEmpty = function isEmpty(set) {\n  return PointMap.isEmpty(set);\n};\n/** Returns an array of the set points */\n\nexport function toArray(set) {\n  return reduce(function (acc, point) {\n    return [].concat(_toConsumableArray(acc), [point]);\n  }, set, []);\n}\nvar NO_EDGE = {\n  left: false,\n  right: false,\n  top: false,\n  bottom: false\n};\nexport function onEdge(set, point) {\n  if (!has(set, point)) {\n    return NO_EDGE;\n  }\n\n  var hasNot = function hasNot(rowDelta, columnDelta) {\n    return !has(set, {\n      row: point.row + rowDelta,\n      column: point.column + columnDelta\n    });\n  };\n\n  return {\n    left: hasNot(0, -1),\n    right: hasNot(0, 1),\n    top: hasNot(-1, 0),\n    bottom: hasNot(1, 0)\n  };\n}\nexport function getEdgeValue(set, field, delta) {\n  var compare = Math.sign(delta) === -1 ? Math.min : Math.max;\n\n  if (size(set) === 0) {\n    throw new Error(\"getEdgeValue() should never be called with an empty set\");\n  } // $FlowFixMe\n\n\n  return reduce(function (acc, point) {\n    if (acc === null) {\n      return point[field];\n    }\n\n    return compare(acc, point[field]);\n  }, set, null);\n}\nexport function extendEdge(set, field, delta) {\n  var oppositeField = field === \"row\" ? \"column\" : \"row\";\n  var edgeValue = getEdgeValue(set, field, delta);\n  return reduce(function (acc, point) {\n    if (point[field] === edgeValue) {\n      var _add;\n\n      return add(acc, (_add = {}, _defineProperty(_add, field, edgeValue + delta), _defineProperty(_add, oppositeField, point[oppositeField]), _add));\n    }\n\n    return acc;\n  }, set, set);\n}\nexport function shrinkEdge(set, field, delta) {\n  var edgeValue = getEdgeValue(set, field, delta);\n  return reduce(function (acc, point) {\n    if (point[field] === edgeValue) {\n      return remove(acc, point);\n    }\n\n    return acc;\n  }, set, set);\n}"]},"metadata":{},"sourceType":"module"}