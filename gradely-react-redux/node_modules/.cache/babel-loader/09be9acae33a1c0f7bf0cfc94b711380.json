{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { registerPlugin } from './../../plugins';\nimport { stopImmediatePropagation } from './../../helpers/dom/event';\nimport { CellCoords, CellRange } from './../../3rdparty/walkontable/src';\nimport MergedCellsCollection from './cellsCollection';\nimport MergedCellCoords from './cellCoords';\nimport AutofillCalculations from './calculations/autofill';\nimport SelectionCalculations from './calculations/selection';\nimport toggleMergeItem from './contextMenuItem/toggleMerge';\nimport { arrayEach } from '../../helpers/array';\nimport { clone } from '../../helpers/object';\nimport { warn } from '../../helpers/console';\nimport { rangeEach } from '../../helpers/number';\nimport { applySpanProperties } from './utils';\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nvar MergeCells = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n\n  function MergeCells(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, MergeCells);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeCells).call(this, hotInstance));\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings().mergeCells;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings().mergeCells;\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {Object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n\n      if (!setting) {\n        return false;\n      }\n\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|Boolean} settings The settings provided to the plugin.\n     */\n\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n\n      if (Array.isArray(settings)) {\n        var _this$hot;\n\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @return {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n            mergedCellRowIndex = _mergedCellArguments[0],\n            mergedCellColumnIndex = _mergedCellArguments[1],\n            mergedCellData = _mergedCellArguments[2];\n\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection])\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @return {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex])\n     */\n\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {Object} newMergedCellInfo Merged cell information object to test.\n     * @param {Boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n\n      if (!currentRange) {\n        return;\n      }\n\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n          to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {Boolean} [auto=false] `true` if is called automatically, e.g. at initialization.\n     * @param {Boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|Boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {Boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n\n      if (!mergedCells) {\n        return;\n      }\n\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.render();\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings().mergeCells);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {Boolean} isMultiple\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.highlight.row === mergedCells[group].row && selectionRange.highlight.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextParentIsMerged = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n\n      if (nextParentIsMerged) {\n        // skipping the invisible cells in the merge range\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: nextParentIsMerged.row - currentPosition.row,\n          col: nextParentIsMerged.col - currentPosition.col\n        };\n      }\n\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n      return mergeParent ? [mergeParent.row, mergeParent.col, mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1] : void 0;\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {Object} defaultOptions The default context menu options.\n     */\n\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     */\n\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col);\n      applySpanProperties(TD, mergedCell, row, col);\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell\n     *\n     * @private\n     * @param {Object} coords Cell coords.\n     */\n\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n\n      do {\n        rangeExpanded = false;\n\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     * @param {Object} cellProperties The cell properties object.\n     */\n\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The row calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var _this7 = this;\n\n      var colCount = this.hot.countCols();\n      var mergeParent;\n      rangeEach(0, colCount - 1, function (c) {\n        mergeParent = _this7.mergedCellsCollection.get(calc.startRow, c);\n\n        if (mergeParent) {\n          if (mergeParent.row < calc.startRow) {\n            calc.startRow = mergeParent.row;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        mergeParent = _this7.mergedCellsCollection.get(calc.endRow, c);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;\n\n          if (mergeEnd > calc.endRow) {\n            calc.endRow = mergeEnd;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The column calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var _this8 = this;\n\n      var rowCount = this.hot.countRows();\n      var mergeParent;\n      rangeEach(0, rowCount - 1, function (r) {\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.startColumn);\n\n        if (mergeParent && mergeParent.col < calc.startColumn) {\n          calc.startColumn = mergeParent.col;\n          return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n        }\n\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.endColumn);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.col + mergeParent.colspan - 1;\n\n          if (mergeEnd > calc.endColumn) {\n            calc.endColumn = mergeEnd;\n            return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @return {Array} The new drag area.\n     */\n\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of created columns.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of removed columns.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of created rows.\n     * @param {String} source Source of change.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of removed rows.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {String} source Determines the source of the change.\n     */\n\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Coordinates of the area corners.\n     * @param {String} className Class name for the area.\n     */\n\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {Number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down)\n     * @param {Number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down)\n     */\n\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n\n      if (!mergedCellAtCoords) {\n        return;\n      }\n\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }]);\n\n  return MergeCells;\n}(BasePlugin);\n\nregisterPlugin('mergeCells', MergeCells);\nexport default MergeCells;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/plugins/mergeCells/mergeCells.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Object","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","from","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","BasePlugin","Hooks","registerPlugin","stopImmediatePropagation","CellCoords","CellRange","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","clone","warn","rangeEach","applySpanProperties","getSingleton","register","privatePool","WeakMap","MergeCells","_BasePlugin","hotInstance","_this","set","lastDesiredCoords","mergedCellsCollection","autofillCalculations","selectionCalculations","isEnabled","hot","getSettings","mergeCells","enablePlugin","_this2","enabled","addHook","onAfterInit","apply","arguments","onBeforeKeyDown","onModifyTransformStart","onAfterModifyTransformStart","onModifyTransformEnd","onModifyGetCellCoords","onBeforeSetRangeEnd","onAfterIsMultipleSelection","onAfterRenderer","addMergeActionsToContextMenu","onAfterGetCellMeta","onAfterViewportRowCalculatorOverride","onAfterViewportColumnCalculatorOverride","onModifyAutofillRange","onAfterCreateCol","onAfterRemoveCol","onAfterCreateRow","onAfterRemoveRow","onAfterChange","onBeforeDrawAreaBorders","onAfterDrawSelection","onBeforeRemoveCellClassNames","disablePlugin","clearCollections","render","updatePlugin","settings","generateFromSettings","validateSetting","setting","valid","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","_this3","_this$hot","populationArgumentsList","highlight","row","col","rangeEnd","rowspan","colspan","mergeRange","filter","bulkPopulationData","getBulkCollectionData","populateFromArray","_this$hot2","populationDataRange","getBulkCollectionDataRange","dataAtRange","getData","newDataAtRange","splice","mergedCellArguments","_mergedCellArguments","mergedCellRowIndex","mergedCellColumnIndex","mergedCellData","mergedCellRow","rowIndex","mergedCellElement","columnIndex","start","end","mergedCellColumn","Math","min","max","concat","clear","canMergeRange","newMergedCellInfo","auto","toggleMergeOnSelection","currentRange","getSelectedRangeLast","setDirection","to","toggleMerge","selectCell","mergeSelection","cellRange","unmergeRange","unmergeSelection","_this4","preventPopulation","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getDataAtCell","setCellMeta","mergedCellAdded","add","pluginName","_this5","mergedCells","getWithinRange","currentCollection","remove","removeCellMeta","mergedCell","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","unmerge","event","ctrlDown","ctrlKey","metaKey","altKey","keyCode","isMultiple","selectionRange","group","delta","priv","currentlySelectedRange","newDelta","nextPosition","currentPosition","mergedParent","mergeTopLeft","mergeBottomRight","includes","nextParentIsMerged","_this6","currentSelectionRange","newSelectionRange","getUpdatedSelectionRange","tempDelta","mergedCellsWithinRange","snapDelta","column","defaultOptions","items","name","TD","coords","selRange","rangeExpanded","selection","isSelectedByColumnHeader","isSelectedByRowHeader","cellInfo","mergedCellRange","getRange","expandByRange","cellProperties","copyable","calc","_this7","colCount","c","mergeEnd","_this8","rowCount","r","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","source","changes","recreateAfterDataPopulation","corners","className","selectedRange","getLastRow","getLastColumn","rowTransformDir","colTransformDir","mergedCellAtCoords","goingDown","goingUp","goingLeft","goingRight","mergedCellOnBottomEdge","mergedCellOnTopEdge","mergedCellOnRightEdge","mergedCellOnLeftEdge","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.filter\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.get-own-property-descriptor\";\nimport \"core-js/modules/es.object.get-prototype-of\";\nimport \"core-js/modules/es.object.set-prototype-of\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.reflect.get\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.weak-map\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { registerPlugin } from './../../plugins';\nimport { stopImmediatePropagation } from './../../helpers/dom/event';\nimport { CellCoords, CellRange } from './../../3rdparty/walkontable/src';\nimport MergedCellsCollection from './cellsCollection';\nimport MergedCellCoords from './cellCoords';\nimport AutofillCalculations from './calculations/autofill';\nimport SelectionCalculations from './calculations/selection';\nimport toggleMergeItem from './contextMenuItem/toggleMerge';\nimport { arrayEach } from '../../helpers/array';\nimport { clone } from '../../helpers/object';\nimport { warn } from '../../helpers/console';\nimport { rangeEach } from '../../helpers/number';\nimport { applySpanProperties } from './utils';\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nvar MergeCells =\n/*#__PURE__*/\nfunction (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n\n  function MergeCells(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, MergeCells);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeCells).call(this, hotInstance));\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings().mergeCells;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings().mergeCells;\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {Object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n\n      if (!setting) {\n        return false;\n      }\n\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|Boolean} settings The settings provided to the plugin.\n     */\n\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n\n      if (Array.isArray(settings)) {\n        var _this$hot;\n\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @return {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n            mergedCellRowIndex = _mergedCellArguments[0],\n            mergedCellColumnIndex = _mergedCellArguments[1],\n            mergedCellData = _mergedCellArguments[2];\n\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection])\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @return {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex])\n     */\n\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {Object} newMergedCellInfo Merged cell information object to test.\n     * @param {Boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n\n      if (!currentRange) {\n        return;\n      }\n\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n          to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {Boolean} [auto=false] `true` if is called automatically, e.g. at initialization.\n     * @param {Boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|Boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {Boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n\n      if (!mergedCells) {\n        return;\n      }\n\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.render();\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings().mergeCells);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {Boolean} isMultiple\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.highlight.row === mergedCells[group].row && selectionRange.highlight.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextParentIsMerged = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n\n      if (nextParentIsMerged) {\n        // skipping the invisible cells in the merge range\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: nextParentIsMerged.row - currentPosition.row,\n          col: nextParentIsMerged.col - currentPosition.col\n        };\n      }\n\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n      return mergeParent ? [mergeParent.row, mergeParent.col, mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1] : void 0;\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {Object} defaultOptions The default context menu options.\n     */\n\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     */\n\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col);\n      applySpanProperties(TD, mergedCell, row, col);\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell\n     *\n     * @private\n     * @param {Object} coords Cell coords.\n     */\n\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n\n      do {\n        rangeExpanded = false;\n\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     * @param {Object} cellProperties The cell properties object.\n     */\n\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The row calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var _this7 = this;\n\n      var colCount = this.hot.countCols();\n      var mergeParent;\n      rangeEach(0, colCount - 1, function (c) {\n        mergeParent = _this7.mergedCellsCollection.get(calc.startRow, c);\n\n        if (mergeParent) {\n          if (mergeParent.row < calc.startRow) {\n            calc.startRow = mergeParent.row;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        mergeParent = _this7.mergedCellsCollection.get(calc.endRow, c);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;\n\n          if (mergeEnd > calc.endRow) {\n            calc.endRow = mergeEnd;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The column calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var _this8 = this;\n\n      var rowCount = this.hot.countRows();\n      var mergeParent;\n      rangeEach(0, rowCount - 1, function (r) {\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.startColumn);\n\n        if (mergeParent && mergeParent.col < calc.startColumn) {\n          calc.startColumn = mergeParent.col;\n          return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n        }\n\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.endColumn);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.col + mergeParent.colspan - 1;\n\n          if (mergeEnd > calc.endColumn) {\n            calc.endColumn = mergeEnd;\n            return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @return {Array} The new drag area.\n     */\n\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of created columns.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of removed columns.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of created rows.\n     * @param {String} source Source of change.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of removed rows.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {String} source Determines the source of the change.\n     */\n\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Coordinates of the area corners.\n     * @param {String} className Class name for the area.\n     */\n\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {Number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down)\n     * @param {Number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down)\n     */\n\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n\n      if (!mergedCellAtCoords) {\n        return;\n      }\n\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }]);\n\n  return MergeCells;\n}(BasePlugin);\n\nregisterPlugin('mergeCells', MergeCells);\nexport default MergeCells;"]},"metadata":{},"sourceType":"module"}