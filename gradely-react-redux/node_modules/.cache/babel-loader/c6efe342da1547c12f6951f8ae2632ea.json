{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from './../../../helpers/dom/element';\nimport { isFunction } from './../../../helpers/function';\nimport CellCoords from './cell/coords';\nimport ColumnFilter from './filter/column';\nimport RowFilter from './filter/row';\nimport { Renderer } from './renderer';\nimport Overlay from './overlay/_base';\nimport ColumnUtils from './utils/column';\nimport RowUtils from './utils/row';\n/**\n *\n */\n\nvar Table = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n\n\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return Overlay.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(Overlay.CLONE_BOTTOM) || this.is(Overlay.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(Overlay.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(Overlay.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n\n        wtOverlays.leftOverlay.resetFixedPosition();\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = innerHeight(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(Overlay.CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      if (row < 0) {\n        row = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      if (column < 0) {\n        column = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nexport default Table;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/3rdparty/walkontable/src/table.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","hasClass","index","offset","removeClass","removeTextNodes","overlayContainsElement","closest","outerWidth","innerHeight","isVisible","_isVisible","isFunction","CellCoords","ColumnFilter","RowFilter","Renderer","Overlay","ColumnUtils","RowUtils","Table","wotInstance","table","_this","isMaster","cloneOverlay","wot","TABLE","TBODY","THEAD","COLGROUP","tableOffset","holderOffset","hasTableHeight","hasTableWidth","isTableVisible","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","wtSettings","settings","rowHeaderWidth","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","cellRenderer","is","overlayTypeName","isOverlayTypeOf","rootDocument","querySelector","createElement","appendChild","insertBefore","getSetting","childNodes","parent","nodeType","Node","ELEMENT_NODE","className","style","position","draw","fastDraw","arguments","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","createRenderCalculators","leftScrollPos","leftOverlay","getScrollPosition","previousState","prepareOverlays","createVisibleCalculators","refresh","cloneSource","wtTable","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","CLONE_BOTTOM","CLONE_BOTTOM_LEFT_CORNER","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","getWorkspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","adjustElementsSize","refreshSelections","topOverlay","resetFixedPosition","bottomOverlay","clone","topLeftCornerOverlay","bottomLeftCornerOverlay","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","isNaN","children","len","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","selections","highlights","classesToRemove","_highlights$i$setting","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","zeroBasedHeaderLevel","TR","sourceToRendered","Error","TD","sourceColumnToVisibleRowHeadedColumn","getRowHeader","getCoords","cellElement","nodeName","CONTAINER","cellIndex","CLONE_TOP_LEFT_CORNER","CLONE_TOP","visibleColHeadedRowToSourceRow","CLONE_LEFT","offsettedTH","visibleRowHeadedColumnToSourceColumn","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderLevelRendered","isRowHeaderLevelRendered","first","isRowAfterViewport","getLastVisibleRow","getLastRenderedRow","isColumnBeforeViewport","isColumnAfterViewport","getLastVisibleColumn","getLastRenderedColumn","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","width"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from './../../../helpers/dom/element';\nimport { isFunction } from './../../../helpers/function';\nimport CellCoords from './cell/coords';\nimport ColumnFilter from './filter/column';\nimport RowFilter from './filter/row';\nimport { Renderer } from './renderer';\nimport Overlay from './overlay/_base';\nimport ColumnUtils from './utils/column';\nimport RowUtils from './utils/row';\n/**\n *\n */\n\nvar Table =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return Overlay.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(Overlay.CLONE_BOTTOM) || this.is(Overlay.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(Overlay.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(Overlay.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n\n        wtOverlays.leftOverlay.resetFixedPosition();\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = innerHeight(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(Overlay.CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      if (row < 0) {\n        row = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      if (column < 0) {\n        column = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nexport default Table;"]},"metadata":{},"sourceType":"module"}