{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport SheetClip from './../lib/SheetClip/SheetClip';\nimport { cellMethodLookupFactory } from './helpers/data';\nimport { columnFactory } from './helpers/setting';\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from './helpers/object';\nimport { extendArray, to2dArray } from './helpers/array';\nimport Interval from './utils/interval';\nimport { rangeEach } from './helpers/number';\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names\n * @todo refactor arguments of methods getRange, getText to be numbers (not objects)\n * @todo remove priv, GridSettings from object constructor\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap = /*#__PURE__*/function () {\n  _createClass(DataMap, null, [{\n    key: \"DESTINATION_RENDERER\",\n\n    /**\n     * @type {Number}\n     */\n    get: function get() {\n      return 1;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {Object} instance Instance of Handsontable\n     * @param {*} priv\n     * @param {GridSettings} GridSettings Grid settings\n     */\n\n  }]);\n\n  function DataMap(instance, priv, GridSettings) {\n    var _this = this;\n\n    _classCallCheck(this, DataMap);\n    /**\n     * Instance of {@link Handsontable}\n     *\n     * @private\n     * @type {Handsontable}\n     */\n\n\n    this.instance = instance;\n    /**\n     * Private settings object.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.priv = priv;\n    /**\n     * Instance of {@link GridSettings}\n     *\n     * @private\n     * @type {GridSettings}\n     */\n\n    this.GridSettings = GridSettings;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = this.instance.getSettings().data;\n    /**\n     * Cached rows number.\n     *\n     * @type {Number}\n     */\n\n    this.cachedLength = null;\n    /**\n     * Flag determines if the cache should be used.\n     *\n     * @type {Boolean}\n     */\n\n    this.skipCache = false;\n    /**\n     * Cached sourceData rows number.\n     *\n     * @type {Number}\n     */\n\n    this.latestSourceRowsCount = 0;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {Object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n    /**\n     * Instance of {@link Interval}\n     *\n     * @type {Interval}\n     */\n\n    this.interval = Interval.create(function () {\n      return _this.clearLengthCache();\n    }, '15fps');\n    this.instance.addHook('skipLengthCache', function (delay) {\n      return _this.onSkipLengthCache(delay);\n    });\n    this.onSkipLengthCache(500);\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n      var i;\n\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n      var columns = this.instance.getSettings().columns;\n\n      if (columns) {\n        var maxCols = this.instance.getSettings().maxCols;\n        var columnsLen = Math.min(maxCols, columns.length);\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n        var schemaLen = deepObjectSize(schema);\n\n        if (typeof columns === 'function') {\n          columnsLen = schemaLen > 0 ? schemaLen : this.instance.countSourceCols();\n          columnsAsFunc = true;\n        }\n\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {Object} schema\n     * @param {Number} lastCol\n     * @param {Number} parent\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this2 = this;\n\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n\n            _this2.colToPropCache.push(prop);\n\n            _this2.propToColCache.set(prop, lastColumn);\n\n            lastColumn += 1;\n          } else {\n            lastColumn = _this2.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {Number} col Visual column index.\n     * @returns {Number} Physical column index.\n     */\n\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(col) {\n      var physicalColumn = this.instance.toPhysicalColumn(col);\n\n      if (!isNaN(physicalColumn) && this.colToPropCache && typeof this.colToPropCache[physicalColumn] !== 'undefined') {\n        return this.colToPropCache[physicalColumn];\n      }\n\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {Object} prop\n     * @fires Hooks#modifyCol\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var col;\n\n      if (typeof this.propToColCache.get(prop) === 'undefined') {\n        col = prop;\n      } else {\n        col = this.propToColCache.get(prop);\n      }\n\n      col = this.instance.toVisualColumn(col);\n      return col;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.instance.getSettings().dataSchema;\n\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n\n        return schema;\n      }\n\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {Number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {Number} [amount=1] An amount of rows to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {Number} Returns number of created rows.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this3 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n\n      if (typeof rowIndex !== 'number' || rowIndex >= this.instance.countSourceRows()) {\n        rowIndex = this.instance.countSourceRows();\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      var maxRows = this.instance.getSettings().maxRows;\n      var columnCount = this.instance.countCols();\n\n      var _loop = function _loop() {\n        var row = null;\n\n        if (_this3.instance.dataType === 'array') {\n          if (_this3.instance.getSettings().dataSchema) {\n            // Clone template array\n            row = deepClone(_this3.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this3.instance.dataType === 'function') {\n          row = _this3.instance.getSettings().dataSchema(rowIndex);\n        } else {\n          row = {};\n          deepExtend(row, _this3.getSchema());\n        }\n\n        if (rowIndex === _this3.instance.countSourceRows()) {\n          _this3.dataSource.push(row);\n        } else {\n          _this3.spliceData(rowIndex, 0, row);\n        }\n\n        numberOfCreatedRows += 1;\n      };\n\n      while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {\n        _loop();\n      }\n\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {Number} [index] Visual index of the column before which the new column will be inserted\n     * @param {Number} [amount=1] An amount of columns to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {Number} Returns number of created columns\n     */\n\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n\n      var rlen = this.instance.countSourceRows();\n      var data = this.dataSource;\n      var countColumns = this.instance.countCols();\n      var columnIndex = typeof index !== 'number' || index >= countColumns ? countColumns : index;\n      var numberOfCreatedCols = 0;\n      var currentIndex;\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      currentIndex = columnIndex;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {\n        var _constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);\n\n        if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countCols()) {\n          if (rlen > 0) {\n            for (var r = 0; r < rlen; r++) {\n              if (typeof data[r] === 'undefined') {\n                data[r] = [];\n              }\n\n              data[r].push(null);\n            }\n          } else {\n            data.push([null]);\n          } // Add new column constructor\n\n\n          this.priv.columnSettings.push(_constructor);\n        } else {\n          for (var row = 0; row < rlen; row++) {\n            data[row].splice(currentIndex, 0, null);\n          } // Add new column constructor at given index\n\n\n          this.priv.columnSettings.splice(currentIndex, 0, _constructor);\n        }\n\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n      }\n\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @param {Number} [index] Visual index of the row to be removed. If not provided, the last row will be removed\n     * @param {Number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = typeof index !== 'number' ? -amount : index;\n      var rowsAmount = this.instance.runHooks('modifyRemovedAmount', amount, rowIndex);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;\n      var logicRows = this.visualRowsToPhysical(rowIndex, rowsAmount);\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, rowsAmount, logicRows, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var data = this.dataSource;\n      var newData = this.filterData(rowIndex, rowsAmount);\n\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      }\n\n      this.instance.runHooks('afterRemoveRow', rowIndex, rowsAmount, logicRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @param {Number} [index] Visual index of the column to be removed. If not provided, the last column will be removed\n     * @param {Number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     */\n\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n\n        for (var _c2 = 0; _c2 < removedColumnsCount; _c2++) {\n          this.priv.columnSettings.splice(logicColumns[_c2], 1);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {Number} col Physical index of column in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of columns\n     */\n\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {Number} row Physical index of row in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of rows\n     */\n\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {Number} index Physical index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @param {Object} element Row to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, element);\n\n      if (continueSplicing !== false) {\n        this.dataSource.splice(index, amount, element);\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {Number} index Visual index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount) {\n      var physicalRows = this.visualRowsToPhysical(index, amount);\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @returns {*}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n\n        if (!out) {\n          return null;\n        }\n\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} prop\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @param {String} value\n     * @param {String} [source] Source of hook runner.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value, source) {\n      var physicalRow = this.instance.runHooks('modifyRow', row, source || 'datamapGet');\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n\n          out = out[sliced[i]];\n        }\n\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. when sorting is applied).\n     *\n     * @param {Number} index Visual row index.\n     * @param {Number} amount\n     * @fires Hooks#modifyRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n\n      return logicRows;\n    }\n    /**\n     *\n     * @param index Visual column index.\n     * @param amount\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Clear cached data length.\n     */\n\n  }, {\n    key: \"clearLengthCache\",\n    value: function clearLengthCache() {\n      this.cachedLength = null;\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var _this4 = this;\n\n      var maxRowsFromSettings = this.instance.getSettings().maxRows;\n      var maxRows;\n\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n\n      var length = this.instance.countSourceRows();\n\n      if (this.instance.hasHook('modifyRow')) {\n        var reValidate = this.skipCache;\n        this.interval.start();\n\n        if (length !== this.latestSourceRowsCount) {\n          reValidate = true;\n        }\n\n        this.latestSourceRowsCount = length;\n\n        if (this.cachedLength === null || reValidate) {\n          rangeEach(length - 1, function (row) {\n            var physicalRow = _this4.instance.toPhysicalRow(row);\n\n            if (physicalRow === null) {\n              length -= 1;\n            }\n          });\n          this.cachedLength = length;\n        } else {\n          length = this.cachedLength;\n        }\n      } else {\n        this.interval.stop();\n      }\n\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countSourceRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @param {Number} destination Destination of datamap.get\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.instance.getSettings().maxRows;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = [];\n        var physicalRow = this.instance.toPhysicalRow(r);\n\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * `skipLengthCache` callback.\n     *\n     * @private\n     * @param {Number} delay Time of the delay in milliseconds.\n     */\n\n  }, {\n    key: \"onSkipLengthCache\",\n    value: function onSkipLengthCache(delay) {\n      var _this5 = this;\n\n      this.skipCache = true;\n      setTimeout(function () {\n        _this5.skipCache = false;\n      }, delay);\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.interval.stop();\n      this.interval = null;\n      this.instance = null;\n      this.priv = null;\n      this.GridSettings = null;\n      this.dataSource = null;\n      this.cachedLength = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }]);\n\n  return DataMap;\n}();\n\nexport default DataMap;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/dataMap.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","SheetClip","cellMethodLookupFactory","columnFactory","createObjectPropListener","deepClone","deepExtend","deepObjectSize","duckSchema","hasOwnProperty","isObject","objectEach","extendArray","to2dArray","Interval","rangeEach","copyableLookup","DataMap","get","priv","GridSettings","_this","dataSource","getSettings","data","cachedLength","skipCache","latestSourceRowsCount","colToPropCache","propToColCache","createMap","interval","create","clearLengthCache","addHook","delay","onSkipLengthCache","value","schema","getSchema","Error","Map","columns","maxCols","columnsLen","Math","min","filteredIndex","columnsAsFunc","schemaLen","countSourceCols","column","index","set","recursiveDuckColumns","lastCol","parent","_this2","lastColumn","propertyParent","prop","Array","isArray","push","concat","colToProp","col","physicalColumn","toPhysicalColumn","isNaN","propToCol","toVisualColumn","dataSchema","createRow","_this3","amount","arguments","undefined","source","numberOfCreatedRows","rowIndex","countSourceRows","continueProcess","runHooks","maxRows","columnCount","countCols","_loop","row","dataType","spliceData","forceFullRender","createCol","isColumnModificationAllowed","rlen","countColumns","columnIndex","numberOfCreatedCols","currentIndex","_constructor","columnsSettingConflicts","r","columnSettings","splice","removeRow","rowsAmount","sourceRowsLength","logicRows","visualRowsToPhysical","actionWasNotCancelled","newData","filterData","apply","removeCol","logicColumns","visualColumnsToPhysical","descendingLogicColumns","slice","sort","a","b","isTableUniform","removedColumnsCount","c","_r","_rlen","_c","_c2","spliceCol","colData","getDataAtCol","removed","after","_len","elements","_key","populateFromArray","spliceRow","rowData","getSourceDataAtRow","_len2","_key2","element","continueSplicing","physicalRows","filter","indexOf","physicalRow","toPhysicalRow","dataRow","modifiedRowData","sliced","split","out","ilen","hasHook","valueHolder","isTouched","getCopyable","call","newValue","totalRows","physicRow","rowsToRemove","totalCols","visualCols","physicalCol","colsToRemove","clear","getLength","_this4","maxRowsFromSettings","Infinity","reValidate","start","stop","getAll","end","max","getRange","DESTINATION_RENDERER","destination","output","getFn","DESTINATION_CLIPBOARD_GENERATOR","clen","getText","stringify","getCopyableText","_this5","setTimeout","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.filter\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.map\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.exec\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.string.split\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nimport \"core-js/modules/web.timers\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport SheetClip from './../lib/SheetClip/SheetClip';\nimport { cellMethodLookupFactory } from './helpers/data';\nimport { columnFactory } from './helpers/setting';\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from './helpers/object';\nimport { extendArray, to2dArray } from './helpers/array';\nimport Interval from './utils/interval';\nimport { rangeEach } from './helpers/number';\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names\n * @todo refactor arguments of methods getRange, getText to be numbers (not objects)\n * @todo remove priv, GridSettings from object constructor\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap =\n/*#__PURE__*/\nfunction () {\n  _createClass(DataMap, null, [{\n    key: \"DESTINATION_RENDERER\",\n\n    /**\n     * @type {Number}\n     */\n    get: function get() {\n      return 1;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {Object} instance Instance of Handsontable\n     * @param {*} priv\n     * @param {GridSettings} GridSettings Grid settings\n     */\n\n  }]);\n\n  function DataMap(instance, priv, GridSettings) {\n    var _this = this;\n\n    _classCallCheck(this, DataMap);\n\n    /**\n     * Instance of {@link Handsontable}\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    this.instance = instance;\n    /**\n     * Private settings object.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.priv = priv;\n    /**\n     * Instance of {@link GridSettings}\n     *\n     * @private\n     * @type {GridSettings}\n     */\n\n    this.GridSettings = GridSettings;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = this.instance.getSettings().data;\n    /**\n     * Cached rows number.\n     *\n     * @type {Number}\n     */\n\n    this.cachedLength = null;\n    /**\n     * Flag determines if the cache should be used.\n     *\n     * @type {Boolean}\n     */\n\n    this.skipCache = false;\n    /**\n     * Cached sourceData rows number.\n     *\n     * @type {Number}\n     */\n\n    this.latestSourceRowsCount = 0;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {Object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n    /**\n     * Instance of {@link Interval}\n     *\n     * @type {Interval}\n     */\n\n    this.interval = Interval.create(function () {\n      return _this.clearLengthCache();\n    }, '15fps');\n    this.instance.addHook('skipLengthCache', function (delay) {\n      return _this.onSkipLengthCache(delay);\n    });\n    this.onSkipLengthCache(500);\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n      var i;\n\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n      var columns = this.instance.getSettings().columns;\n\n      if (columns) {\n        var maxCols = this.instance.getSettings().maxCols;\n        var columnsLen = Math.min(maxCols, columns.length);\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n        var schemaLen = deepObjectSize(schema);\n\n        if (typeof columns === 'function') {\n          columnsLen = schemaLen > 0 ? schemaLen : this.instance.countSourceCols();\n          columnsAsFunc = true;\n        }\n\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {Object} schema\n     * @param {Number} lastCol\n     * @param {Number} parent\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this2 = this;\n\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n\n            _this2.colToPropCache.push(prop);\n\n            _this2.propToColCache.set(prop, lastColumn);\n\n            lastColumn += 1;\n          } else {\n            lastColumn = _this2.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {Number} col Visual column index.\n     * @returns {Number} Physical column index.\n     */\n\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(col) {\n      var physicalColumn = this.instance.toPhysicalColumn(col);\n\n      if (!isNaN(physicalColumn) && this.colToPropCache && typeof this.colToPropCache[physicalColumn] !== 'undefined') {\n        return this.colToPropCache[physicalColumn];\n      }\n\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {Object} prop\n     * @fires Hooks#modifyCol\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var col;\n\n      if (typeof this.propToColCache.get(prop) === 'undefined') {\n        col = prop;\n      } else {\n        col = this.propToColCache.get(prop);\n      }\n\n      col = this.instance.toVisualColumn(col);\n      return col;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.instance.getSettings().dataSchema;\n\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n\n        return schema;\n      }\n\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {Number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {Number} [amount=1] An amount of rows to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {Number} Returns number of created rows.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this3 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n\n      if (typeof rowIndex !== 'number' || rowIndex >= this.instance.countSourceRows()) {\n        rowIndex = this.instance.countSourceRows();\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      var maxRows = this.instance.getSettings().maxRows;\n      var columnCount = this.instance.countCols();\n\n      var _loop = function _loop() {\n        var row = null;\n\n        if (_this3.instance.dataType === 'array') {\n          if (_this3.instance.getSettings().dataSchema) {\n            // Clone template array\n            row = deepClone(_this3.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this3.instance.dataType === 'function') {\n          row = _this3.instance.getSettings().dataSchema(rowIndex);\n        } else {\n          row = {};\n          deepExtend(row, _this3.getSchema());\n        }\n\n        if (rowIndex === _this3.instance.countSourceRows()) {\n          _this3.dataSource.push(row);\n        } else {\n          _this3.spliceData(rowIndex, 0, row);\n        }\n\n        numberOfCreatedRows += 1;\n      };\n\n      while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {\n        _loop();\n      }\n\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {Number} [index] Visual index of the column before which the new column will be inserted\n     * @param {Number} [amount=1] An amount of columns to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {Number} Returns number of created columns\n     */\n\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n\n      var rlen = this.instance.countSourceRows();\n      var data = this.dataSource;\n      var countColumns = this.instance.countCols();\n      var columnIndex = typeof index !== 'number' || index >= countColumns ? countColumns : index;\n      var numberOfCreatedCols = 0;\n      var currentIndex;\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      currentIndex = columnIndex;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {\n        var _constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);\n\n        if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countCols()) {\n          if (rlen > 0) {\n            for (var r = 0; r < rlen; r++) {\n              if (typeof data[r] === 'undefined') {\n                data[r] = [];\n              }\n\n              data[r].push(null);\n            }\n          } else {\n            data.push([null]);\n          } // Add new column constructor\n\n\n          this.priv.columnSettings.push(_constructor);\n        } else {\n          for (var row = 0; row < rlen; row++) {\n            data[row].splice(currentIndex, 0, null);\n          } // Add new column constructor at given index\n\n\n          this.priv.columnSettings.splice(currentIndex, 0, _constructor);\n        }\n\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n      }\n\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @param {Number} [index] Visual index of the row to be removed. If not provided, the last row will be removed\n     * @param {Number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = typeof index !== 'number' ? -amount : index;\n      var rowsAmount = this.instance.runHooks('modifyRemovedAmount', amount, rowIndex);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;\n      var logicRows = this.visualRowsToPhysical(rowIndex, rowsAmount);\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, rowsAmount, logicRows, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var data = this.dataSource;\n      var newData = this.filterData(rowIndex, rowsAmount);\n\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      }\n\n      this.instance.runHooks('afterRemoveRow', rowIndex, rowsAmount, logicRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @param {Number} [index] Visual index of the column to be removed. If not provided, the last column will be removed\n     * @param {Number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     */\n\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n\n        for (var _c2 = 0; _c2 < removedColumnsCount; _c2++) {\n          this.priv.columnSettings.splice(logicColumns[_c2], 1);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {Number} col Physical index of column in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of columns\n     */\n\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {Number} row Physical index of row in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of rows\n     */\n\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {Number} index Physical index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @param {Object} element Row to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, element);\n\n      if (continueSplicing !== false) {\n        this.dataSource.splice(index, amount, element);\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {Number} index Visual index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount) {\n      var physicalRows = this.visualRowsToPhysical(index, amount);\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @returns {*}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n\n        if (!out) {\n          return null;\n        }\n\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} prop\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @param {String} value\n     * @param {String} [source] Source of hook runner.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value, source) {\n      var physicalRow = this.instance.runHooks('modifyRow', row, source || 'datamapGet');\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n\n          out = out[sliced[i]];\n        }\n\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. when sorting is applied).\n     *\n     * @param {Number} index Visual row index.\n     * @param {Number} amount\n     * @fires Hooks#modifyRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n\n      return logicRows;\n    }\n    /**\n     *\n     * @param index Visual column index.\n     * @param amount\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Clear cached data length.\n     */\n\n  }, {\n    key: \"clearLengthCache\",\n    value: function clearLengthCache() {\n      this.cachedLength = null;\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var _this4 = this;\n\n      var maxRowsFromSettings = this.instance.getSettings().maxRows;\n      var maxRows;\n\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n\n      var length = this.instance.countSourceRows();\n\n      if (this.instance.hasHook('modifyRow')) {\n        var reValidate = this.skipCache;\n        this.interval.start();\n\n        if (length !== this.latestSourceRowsCount) {\n          reValidate = true;\n        }\n\n        this.latestSourceRowsCount = length;\n\n        if (this.cachedLength === null || reValidate) {\n          rangeEach(length - 1, function (row) {\n            var physicalRow = _this4.instance.toPhysicalRow(row);\n\n            if (physicalRow === null) {\n              length -= 1;\n            }\n          });\n          this.cachedLength = length;\n        } else {\n          length = this.cachedLength;\n        }\n      } else {\n        this.interval.stop();\n      }\n\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countSourceRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @param {Number} destination Destination of datamap.get\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.instance.getSettings().maxRows;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = [];\n        var physicalRow = this.instance.toPhysicalRow(r);\n\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * `skipLengthCache` callback.\n     *\n     * @private\n     * @param {Number} delay Time of the delay in milliseconds.\n     */\n\n  }, {\n    key: \"onSkipLengthCache\",\n    value: function onSkipLengthCache(delay) {\n      var _this5 = this;\n\n      this.skipCache = true;\n      setTimeout(function () {\n        _this5.skipCache = false;\n      }, delay);\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.interval.stop();\n      this.interval = null;\n      this.instance = null;\n      this.priv = null;\n      this.GridSettings = null;\n      this.dataSource = null;\n      this.cachedLength = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }]);\n\n  return DataMap;\n}();\n\nexport default DataMap;"]},"metadata":{},"sourceType":"module"}