{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \\n        or as an array of CellRange objects.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Highlight, { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from './highlight/highlight';\nimport SelectionRange from './range';\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { isPressedCtrlKey } from './../utils/keyStateObserver';\nimport { createObjectPropListener, mixin } from './../helpers/object';\nimport { isUndefined } from './../helpers/mixed';\nimport { arrayEach } from './../helpers/array';\nimport localHooks from './../mixins/localHooks';\nimport Transformation from './transformation';\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from './utils';\nimport { toSingleLine } from './../helpers/templateLiteralTag';\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n\n\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {Object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {Boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {Boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer.\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disableHighlight: this.settings.disableVisualSelection,\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRows();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countCols();\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @return {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {Boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n\n      if (isRowNegative) {\n        coords.row = 0;\n      }\n\n      if (isColumnNegative) {\n        coords.col = 0;\n      }\n\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coords);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      this.runLocalHooks('beforeSetRangeEnd', coords);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to);\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(this.selectedRange.previous().from);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE)) {\n        if (this.settings.selectionMode === 'single') {\n          headerHighlight.add(cellRange.highlight);\n        } else {\n          headerHighlight.add(cellRange.from).add(cellRange.to);\n        }\n      }\n\n      if (this.isSelectedByRowHeader()) {\n        var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n        if (isRowSelected) {\n          activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1));\n        }\n      }\n\n      if (this.isSelectedByColumnHeader()) {\n        var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n        if (isColumnSelected) {\n          activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col));\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @return {Number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {Number} layerLevel The layer level.\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      this.clear();\n      this.setRangeStart(new CellCoords(-1, -1));\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, this.tableProps.countCols() - 1));\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @return {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject()));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var countRows = this.tableProps.countRows();\n      var countCols = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, countRows) && isValidCoord(columnStart, countCols) && isValidCoord(rowEnd, countRows) && isValidCoord(columnEnd, countCols);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at `endColumn`.\n     *\n     * @param {Number|String} startColumn Visual column index or column property from which the selection starts.\n     * @param {Number|String} [endColumn] Visual column index or column property from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var countCols = this.tableProps.countCols();\n      var isValid = isValidCoord(start, countCols) && isValidCoord(end, countCols);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(-1, start));\n        this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {Number} startRow Visual row index from which the selection starts.\n     * @param {Number} [endRow] Visual row index from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var countRows = this.tableProps.countRows();\n      var isValid = isValidCoord(startRow, countRows) && isValidCoord(endRow, countRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, -1));\n        this.setRangeEnd(new CellCoords(endRow, this.tableProps.countCols() - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/selection/selection.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_templateObject","data","_taggedTemplateLiteral","strings","raw","slice","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","CellCoords","isPressedCtrlKey","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disableHighlight","disableVisualSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","transformation","countRows","countCols","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","from","isInProgress","setRangeStart","coords","multipleSelection","fragment","isMultipleMode","selectionMode","isMultipleSelection","isRowNegative","row","isColumnNegative","col","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","to","previous","isSelectedByRowHeader","isRowSelected","getWidth","isSelectedByColumnHeader","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","has","isSelectedByAnyHeader","isSelectedByCorner","inInSelection","includes","fillHandle","isEditorOpened","Number","isInteger","deselect","selectAll","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","start","end","selectRows","startRow","endRow"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.some\";\nimport \"core-js/modules/es.number.constructor\";\nimport \"core-js/modules/es.number.is-integer\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.set\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \\n        or as an array of CellRange objects.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport Highlight, { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from './highlight/highlight';\nimport SelectionRange from './range';\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { isPressedCtrlKey } from './../utils/keyStateObserver';\nimport { createObjectPropListener, mixin } from './../helpers/object';\nimport { isUndefined } from './../helpers/mixed';\nimport { arrayEach } from './../helpers/array';\nimport localHooks from './../mixins/localHooks';\nimport Transformation from './transformation';\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from './utils';\nimport { toSingleLine } from './../helpers/templateLiteralTag';\n/**\n * @class Selection\n * @util\n */\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {Object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {Boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {Boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer.\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disableHighlight: this.settings.disableVisualSelection,\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRows();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countCols();\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @return {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {Boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n\n      if (isRowNegative) {\n        coords.row = 0;\n      }\n\n      if (isColumnNegative) {\n        coords.col = 0;\n      }\n\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coords);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      this.runLocalHooks('beforeSetRangeEnd', coords);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to);\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(this.selectedRange.previous().from);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE)) {\n        if (this.settings.selectionMode === 'single') {\n          headerHighlight.add(cellRange.highlight);\n        } else {\n          headerHighlight.add(cellRange.from).add(cellRange.to);\n        }\n      }\n\n      if (this.isSelectedByRowHeader()) {\n        var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n        if (isRowSelected) {\n          activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1));\n        }\n      }\n\n      if (this.isSelectedByColumnHeader()) {\n        var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n        if (isColumnSelected) {\n          activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col));\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @return {Number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {Number} layerLevel The layer level.\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      this.clear();\n      this.setRangeStart(new CellCoords(-1, -1));\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, this.tableProps.countCols() - 1));\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @return {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject()));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var countRows = this.tableProps.countRows();\n      var countCols = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, countRows) && isValidCoord(columnStart, countCols) && isValidCoord(rowEnd, countRows) && isValidCoord(columnEnd, countCols);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at `endColumn`.\n     *\n     * @param {Number|String} startColumn Visual column index or column property from which the selection starts.\n     * @param {Number|String} [endColumn] Visual column index or column property from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var countCols = this.tableProps.countCols();\n      var isValid = isValidCoord(start, countCols) && isValidCoord(end, countCols);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(-1, start));\n        this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {Number} startRow Visual row index from which the selection starts.\n     * @param {Number} [endRow] Visual row index from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var countRows = this.tableProps.countRows();\n      var isValid = isValidCoord(startRow, countRows) && isValidCoord(endRow, countRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, -1));\n        this.setRangeEnd(new CellCoords(endRow, this.tableProps.countCols() - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;"]},"metadata":{},"sourceType":"module"}