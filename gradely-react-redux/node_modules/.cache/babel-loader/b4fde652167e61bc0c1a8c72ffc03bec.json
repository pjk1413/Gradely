{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { CellCoords, CellRange } from './../../../3rdparty/walkontable/src';\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @class SelectionCalculations\n * @plugin MergeCells\n * @util\n */\n\nvar SelectionCalculations = /*#__PURE__*/function () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n\n\n    this.plugin = plugin;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {String}\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.)\n   *\n   * @param {Object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {Object} mergedCell A merged cell object.\n   */\n\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it)\n     *\n     * @private\n     * @param {Object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {Number} newIndex New row/column index, created with the delta.\n     */\n\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {Object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var _cornersOfSelection = _slicedToArray(cornersOfSelection, 4),\n          startRow = _cornersOfSelection[0],\n          startColumn = _cornersOfSelection[1],\n          endRow = _cornersOfSelection[2],\n          endColumn = _cornersOfSelection[3];\n\n      if (layerLevel === void 0) {\n        return;\n      }\n\n      if (currentRow >= startRow && currentRow <= endRow && currentColumn >= startColumn && currentColumn <= endColumn) {\n        var isMergedCellParent = this.plugin.mergedCellsCollection.isMergedParent(currentRow, currentColumn);\n\n        if (!isMergedCellParent) {\n          return;\n        }\n\n        var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n\n        if (!mergedCell) {\n          return;\n        }\n\n        if (mergedCell.row + mergedCell.rowspan - 1 <= endRow && mergedCell.col + mergedCell.colspan - 1 <= endColumn) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n        } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n        }\n      }\n    }\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection)\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n\n  return SelectionCalculations;\n}();\n\nexport default SelectionCalculations;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/mergeCells/calculations/selection.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","CellCoords","CellRange","SelectionCalculations","plugin","fullySelectedMergedCellClassName","snapDelta","delta","selectionRange","mergedCell","cellCoords","to","newRow","row","newColumn","col","jumpOverMergedCell","newIndex","flatDelta","includesIndex","firstIndex","lastIndex","includesVertically","getLastRow","includesHorizontally","getLastColumn","getUpdatedSelectionRange","oldSelectionRange","highlight","from","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","_cornersOfSelection","startRow","startColumn","endRow","endColumn","isMergedCellParent","mergedCellsCollection","isMergedParent","get","rowspan","colspan","concat","selectionCalculations","isMergeCellFullySelected","hot","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","r","c","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { CellCoords, CellRange } from './../../../3rdparty/walkontable/src';\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @class SelectionCalculations\n * @plugin MergeCells\n * @util\n */\n\nvar SelectionCalculations =\n/*#__PURE__*/\nfunction () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {String}\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.)\n   *\n   * @param {Object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {Object} mergedCell A merged cell object.\n   */\n\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it)\n     *\n     * @private\n     * @param {Object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {Number} newIndex New row/column index, created with the delta.\n     */\n\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {Object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var _cornersOfSelection = _slicedToArray(cornersOfSelection, 4),\n          startRow = _cornersOfSelection[0],\n          startColumn = _cornersOfSelection[1],\n          endRow = _cornersOfSelection[2],\n          endColumn = _cornersOfSelection[3];\n\n      if (layerLevel === void 0) {\n        return;\n      }\n\n      if (currentRow >= startRow && currentRow <= endRow && currentColumn >= startColumn && currentColumn <= endColumn) {\n        var isMergedCellParent = this.plugin.mergedCellsCollection.isMergedParent(currentRow, currentColumn);\n\n        if (!isMergedCellParent) {\n          return;\n        }\n\n        var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n\n        if (!mergedCell) {\n          return;\n        }\n\n        if (mergedCell.row + mergedCell.rowspan - 1 <= endRow && mergedCell.col + mergedCell.colspan - 1 <= endColumn) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n        } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n        }\n      }\n    }\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection)\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n\n  return SelectionCalculations;\n}();\n\nexport default SelectionCalculations;"]},"metadata":{},"sourceType":"module"}