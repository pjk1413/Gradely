{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { rangeEach } from '../../../helpers/number';\nimport { objectEach, hasOwnProperty } from '../../../helpers/object';\nimport { arrayEach } from '../../../helpers/array';\nimport { getTranslator } from '../../../utils/recordTranslator';\n/**\n * Class responsible for making data operations.\n *\n * @class\n * @private\n */\n\nvar DataManager = /*#__PURE__*/function () {\n  function DataManager(nestedRowsPlugin, hotInstance, sourceData) {\n    _classCallCheck(this, DataManager);\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {Object}\n     */\n\n\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Object}\n     */\n\n    this.data = sourceData;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {Object}\n     */\n\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {Object}\n     */\n\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    /**\n     * A `recordTranslator` instance.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n\n\n  _createClass(DataManager, [{\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {Object} node Node to cache.\n     * @param {Number} level Level of the node.\n     * @param {Object} parent Parent of the node.\n     */\n\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {Number} row Row index.\n     */\n\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {Object} parent The initial parent object.\n     * @param {Number} readCount Number of read nodes.\n     * @param {Number} neededIndex The row index we search for.\n     * @param {Object} neededObject The row object we search for.\n     * @returns {Number|Object}\n     */\n\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n\n      var rootLevel = false;\n      var readedNodesCount = readCount;\n\n      if (isNaN(readedNodesCount) && readedNodesCount.end) {\n        return readedNodesCount;\n      }\n\n      var parentObj = parent;\n\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readedNodesCount -= 1;\n      }\n\n      if (neededIndex !== null && neededIndex !== void 0 && readedNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readedNodesCount,\n          end: true\n        };\n      }\n\n      readedNodesCount += 1;\n\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n\n          readedNodesCount = _this3.readTreeNodes(val, readedNodesCount, neededIndex, neededObject);\n\n          if (isNaN(readedNodesCount) && readedNodesCount.end) {\n            return false;\n          }\n        });\n      }\n\n      return readedNodesCount;\n    }\n    /**\n     * Update the parent reference map.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"updateParentReference\",\n    value: function updateParentReference() {\n      this.readTreeNodes({\n        __children: this.data\n      }, 0, this.hot.countRows());\n    }\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {Object} rowObj The row object.\n     * @returns {Number} Row index.\n     */\n\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {Number|Object} row Row index / row object.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n\n      var parent = this.getRowParent(row);\n\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n\n      return parent.__children.indexOf(rowObj);\n    }\n    /**\n     * Count all rows (including all parents and children).\n     */\n\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {Object|Number} parent Parent node.\n     * @returns {Number} Children count.\n     */\n\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n\n      var rowCount = 0;\n      var parentNode = parent;\n\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {Number|Object} row Row index.\n     */\n\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return this.getRowObjectParent(rowObject);\n    }\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {Object} rowObject The row object (tree node).\n     */\n\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (_typeof(rowObject) !== 'object') {\n        return null;\n      }\n\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {Number} row Row index.\n     * @returns {Number|null} Row level or null, when row doesn't exist.\n     */\n\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {Object} rowObject Row object.\n     * @returns {Number} Row level.\n     */\n\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {Number|Object} row Row number or row element.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return !!hasOwnProperty(rowObj, '__children');\n    }\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\"\n     *\n     * @param {Object} parent The parent row object.\n     * @param {Object} [element] The element to add as a child.\n     */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      functionalParent.__children.push(childElement);\n\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {Object} parent Parent node.\n     * @param {Number} index Index to insert the child element at.\n     * @param {Object} [element] Element (node) to insert.\n     * @param {Number} [globalIndex] Global index of the inserted row.\n     */\n\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element, globalIndex) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n      this.hot.runHooks('beforeCreateRow', globalIndex + 1, 1);\n      var functionalParent = parent;\n\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      functionalParent.__children.splice(index, null, childElement);\n\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', globalIndex + 1, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {Number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null, index);\n          break;\n\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null, index);\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {Object|Array} elements Row object or an array of selected coordinates.\n     * @param {Boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n\n      var childRowIndex = this.getRowIndex(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, 1, [childRowIndex], this.plugin.pluginName);\n\n        parent.__children.splice(indexWithinParent, 1);\n\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, 1, [childRowIndex], this.plugin.pluginName);\n\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n\n      if (forceRender) {\n        this.hot.render();\n      }\n\n      this.hot.runHooks('afterDetachChild', parent, element);\n    }\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {Number} index Index of the first row to remove.\n     * @param {Number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n\n        var tempParent = _this6.getRowParent(elem);\n\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the default script.\n     *\n     * @private\n     * @param {Number} index Index of the element at the splice beginning.\n     * @param {Number} amount Number of elements to be removed.\n     * @param {Object} element Row to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var elementIndex = this.translateTrimmedRow(index);\n\n      if (elementIndex === null || elementIndex === void 0) {\n        return;\n      }\n\n      var previousElement = this.getDataObject(elementIndex - 1);\n      var newRowParent = null;\n      var indexWithinParent = null;\n\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else {\n        newRowParent = this.getRowParent(elementIndex);\n        indexWithinParent = this.getRowIndexWithinParent(elementIndex);\n      }\n\n      if (newRowParent) {\n        if (element) {\n          newRowParent.__children.splice(indexWithinParent, amount, element);\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (element) {\n        this.data.splice(indexWithinParent, amount, element);\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n\n      this.rewriteCache();\n    }\n    /**\n     * Move a single row.\n     *\n     * @param {Number} fromIndex Index of the row to be moved.\n     * @param {Number} toIndex Index of the destination.\n     */\n\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex) {\n      var targetIsParent = this.isParent(toIndex);\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n      var toParent = this.getRowParent(toIndex);\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n\n      var previousToTargetParent = this.getRowParent(toIndex - 1);\n      var indexInToParent = targetIsParent ? this.countChildren(previousToTargetParent) : this.getRowIndexWithinParent(toIndex);\n\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n\n      fromParent.__children.splice(indexInFromParent, 1);\n\n      toParent.__children.splice(indexInToParent, 0, elemToMove[0]);\n    }\n    /**\n     * Move the cell meta\n     *\n     * @private\n     * @param {Number} fromIndex Index of the starting row.\n     * @param {Number} toIndex Index of the ending row.\n     */\n\n  }, {\n    key: \"moveCellMeta\",\n    value: function moveCellMeta(fromIndex, toIndex) {\n      var rowOfMeta = this.hot.getCellMetaAtRow(fromIndex);\n      this.hot.spliceCellsMeta(toIndex, 0, rowOfMeta);\n      this.hot.spliceCellsMeta(fromIndex + (fromIndex < toIndex ? 0 : 1), 1);\n    }\n    /**\n     * Translate the row index according to the `TrimRows` plugin.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n\n      return row;\n    }\n  }]);\n\n  return DataManager;\n}();\n\nexport default DataManager;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/nestedRows/data/dataManager.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","rangeEach","objectEach","hasOwnProperty","arrayEach","getTranslator","DataManager","nestedRowsPlugin","hotInstance","sourceData","hot","data","plugin","parentReference","WeakMap","cache","levels","levelCount","rows","nodeInfo","recordTranslator","value","rewriteCache","_this","cacheNode","node","level","parent","_this2","push","set","row","hasChildren","__children","elem","getDataObject","readTreeNodes","readCount","neededIndex","neededObject","_this3","rootLevel","readedNodesCount","isNaN","end","parentObj","result","val","updateParentReference","countRows","mockParent","fakeParent","mockNode","fakeNode","getRowIndex","rowObj","get","getRowIndexWithinParent","getRowParent","indexOf","countAllRows","rootNodeMock","countChildren","_this4","rowCount","parentNode","rowObject","getRowObjectParent","getRowLevel","getRowObjectLevel","isParent","addChild","element","childElement","runHooks","parentIndex","functionalParent","newRowIndex","addChildAtIndex","index","globalIndex","splice","addSibling","where","arguments","undefined","translatedIndex","translateTrimmedRow","indexWithinParent","detachFromParent","elements","_this5","forceRender","rowObjects","Array","isArray","childRowIndex","grandparent","grandparentRowIndex","movedElementRowIndex","pluginName","render","filterData","amount","logicRows","_this6","elementsToRemove","tempParent","spliceData","elementIndex","previousElement","newRowParent","moveRow","fromIndex","toIndex","targetIsParent","fromParent","indexInFromParent","toParent","previousToTargetParent","indexInToParent","elemToMove","slice","moveCellMeta","rowOfMeta","getCellMetaAtRow","spliceCellsMeta","collapsingUI"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.weak-map\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { rangeEach } from '../../../helpers/number';\nimport { objectEach, hasOwnProperty } from '../../../helpers/object';\nimport { arrayEach } from '../../../helpers/array';\nimport { getTranslator } from '../../../utils/recordTranslator';\n/**\n * Class responsible for making data operations.\n *\n * @class\n * @private\n */\n\nvar DataManager =\n/*#__PURE__*/\nfunction () {\n  function DataManager(nestedRowsPlugin, hotInstance, sourceData) {\n    _classCallCheck(this, DataManager);\n\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {Object}\n     */\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Object}\n     */\n\n    this.data = sourceData;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {Object}\n     */\n\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {Object}\n     */\n\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    /**\n     * A `recordTranslator` instance.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n\n\n  _createClass(DataManager, [{\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {Object} node Node to cache.\n     * @param {Number} level Level of the node.\n     * @param {Object} parent Parent of the node.\n     */\n\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {Number} row Row index.\n     */\n\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {Object} parent The initial parent object.\n     * @param {Number} readCount Number of read nodes.\n     * @param {Number} neededIndex The row index we search for.\n     * @param {Object} neededObject The row object we search for.\n     * @returns {Number|Object}\n     */\n\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n\n      var rootLevel = false;\n      var readedNodesCount = readCount;\n\n      if (isNaN(readedNodesCount) && readedNodesCount.end) {\n        return readedNodesCount;\n      }\n\n      var parentObj = parent;\n\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readedNodesCount -= 1;\n      }\n\n      if (neededIndex !== null && neededIndex !== void 0 && readedNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readedNodesCount,\n          end: true\n        };\n      }\n\n      readedNodesCount += 1;\n\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n\n          readedNodesCount = _this3.readTreeNodes(val, readedNodesCount, neededIndex, neededObject);\n\n          if (isNaN(readedNodesCount) && readedNodesCount.end) {\n            return false;\n          }\n        });\n      }\n\n      return readedNodesCount;\n    }\n    /**\n     * Update the parent reference map.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"updateParentReference\",\n    value: function updateParentReference() {\n      this.readTreeNodes({\n        __children: this.data\n      }, 0, this.hot.countRows());\n    }\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {Object} rowObj The row object.\n     * @returns {Number} Row index.\n     */\n\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {Number|Object} row Row index / row object.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n\n      var parent = this.getRowParent(row);\n\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n\n      return parent.__children.indexOf(rowObj);\n    }\n    /**\n     * Count all rows (including all parents and children).\n     */\n\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {Object|Number} parent Parent node.\n     * @returns {Number} Children count.\n     */\n\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n\n      var rowCount = 0;\n      var parentNode = parent;\n\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {Number|Object} row Row index.\n     */\n\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return this.getRowObjectParent(rowObject);\n    }\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {Object} rowObject The row object (tree node).\n     */\n\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (_typeof(rowObject) !== 'object') {\n        return null;\n      }\n\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {Number} row Row index.\n     * @returns {Number|null} Row level or null, when row doesn't exist.\n     */\n\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {Object} rowObject Row object.\n     * @returns {Number} Row level.\n     */\n\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {Number|Object} row Row number or row element.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return !!hasOwnProperty(rowObj, '__children');\n    }\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\"\n     *\n     * @param {Object} parent The parent row object.\n     * @param {Object} [element] The element to add as a child.\n     */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      functionalParent.__children.push(childElement);\n\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {Object} parent Parent node.\n     * @param {Number} index Index to insert the child element at.\n     * @param {Object} [element] Element (node) to insert.\n     * @param {Number} [globalIndex] Global index of the inserted row.\n     */\n\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element, globalIndex) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n      this.hot.runHooks('beforeCreateRow', globalIndex + 1, 1);\n      var functionalParent = parent;\n\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      functionalParent.__children.splice(index, null, childElement);\n\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', globalIndex + 1, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {Number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null, index);\n          break;\n\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null, index);\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {Object|Array} elements Row object or an array of selected coordinates.\n     * @param {Boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n\n      var childRowIndex = this.getRowIndex(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, 1, [childRowIndex], this.plugin.pluginName);\n\n        parent.__children.splice(indexWithinParent, 1);\n\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, 1, [childRowIndex], this.plugin.pluginName);\n\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex, 1, this.plugin.pluginName);\n\n      if (forceRender) {\n        this.hot.render();\n      }\n\n      this.hot.runHooks('afterDetachChild', parent, element);\n    }\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {Number} index Index of the first row to remove.\n     * @param {Number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n\n        var tempParent = _this6.getRowParent(elem);\n\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the default script.\n     *\n     * @private\n     * @param {Number} index Index of the element at the splice beginning.\n     * @param {Number} amount Number of elements to be removed.\n     * @param {Object} element Row to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var elementIndex = this.translateTrimmedRow(index);\n\n      if (elementIndex === null || elementIndex === void 0) {\n        return;\n      }\n\n      var previousElement = this.getDataObject(elementIndex - 1);\n      var newRowParent = null;\n      var indexWithinParent = null;\n\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else {\n        newRowParent = this.getRowParent(elementIndex);\n        indexWithinParent = this.getRowIndexWithinParent(elementIndex);\n      }\n\n      if (newRowParent) {\n        if (element) {\n          newRowParent.__children.splice(indexWithinParent, amount, element);\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (element) {\n        this.data.splice(indexWithinParent, amount, element);\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n\n      this.rewriteCache();\n    }\n    /**\n     * Move a single row.\n     *\n     * @param {Number} fromIndex Index of the row to be moved.\n     * @param {Number} toIndex Index of the destination.\n     */\n\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex) {\n      var targetIsParent = this.isParent(toIndex);\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n      var toParent = this.getRowParent(toIndex);\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n\n      var previousToTargetParent = this.getRowParent(toIndex - 1);\n      var indexInToParent = targetIsParent ? this.countChildren(previousToTargetParent) : this.getRowIndexWithinParent(toIndex);\n\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n\n      fromParent.__children.splice(indexInFromParent, 1);\n\n      toParent.__children.splice(indexInToParent, 0, elemToMove[0]);\n    }\n    /**\n     * Move the cell meta\n     *\n     * @private\n     * @param {Number} fromIndex Index of the starting row.\n     * @param {Number} toIndex Index of the ending row.\n     */\n\n  }, {\n    key: \"moveCellMeta\",\n    value: function moveCellMeta(fromIndex, toIndex) {\n      var rowOfMeta = this.hot.getCellMetaAtRow(fromIndex);\n      this.hot.spliceCellsMeta(toIndex, 0, rowOfMeta);\n      this.hot.spliceCellsMeta(fromIndex + (fromIndex < toIndex ? 0 : 1), 1);\n    }\n    /**\n     * Translate the row index according to the `TrimRows` plugin.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n\n      return row;\n    }\n  }]);\n\n  return DataManager;\n}();\n\nexport default DataManager;"]},"metadata":{},"sourceType":"module"}