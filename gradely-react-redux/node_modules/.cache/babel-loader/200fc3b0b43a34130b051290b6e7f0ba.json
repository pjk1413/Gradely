{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { getScrollableElement, getTrimmingContainer } from './../../../../helpers/dom/element';\nimport { defineGetter } from './../../../../helpers/object';\nimport { arrayEach } from './../../../../helpers/array';\nimport { warn } from './../../../../helpers/console';\nimport EventManager from './../../../../eventManager';\nimport Walkontable from './../core';\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay = /*#__PURE__*/function () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n\n  }, {\n    key: \"CLONE_TOP\",\n\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      return new Walkontable({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // When hot settings are changed we allow to refresh overlay once before blocking\n\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();\n\nexport default Overlay;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/3rdparty/walkontable/src/overlay/_base.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollableElement","getTrimmingContainer","defineGetter","arrayEach","warn","EventManager","Walkontable","registeredOverlays","Overlay","value","registerOverlay","type","overlayClass","CLONE_TYPES","indexOf","Error","concat","createOverlay","wot","hasOverlay","isOverlayTypeOf","overlay","get","CLONE_TOP","CLONE_BOTTOM","CLONE_LEFT","CLONE_TOP_LEFT_CORNER","CLONE_BOTTOM_LEFT_CORNER","CLONE_DEBUG","wotInstance","_this$wot$wtTable","wtTable","TABLE","hider","spreader","holder","wtRootElement","mainTableScrollableElement","trimmingContainer","parentNode","areElementSizesAdjusted","updateStateOfRendering","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","_this$wot","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","clone","contains","windowScroll","fixedColumn","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","left","offsetLeft","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","cloneSource","wtOverlays","leftOverlay","getScrollPosition","vertical","topOverlay","makeClone","direction","_this$wot2","rootDocument","createElement","clonedTable","className","style","position","overflow","appendChild","preventOverflow","cloneOverlay","table","refresh","fastDraw","arguments","undefined","nextCycleRenderFlag","draw","holderStyle","hidderStyle","rootStyle","width","height","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.index-of\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { getScrollableElement, getTrimmingContainer } from './../../../../helpers/dom/element';\nimport { defineGetter } from './../../../../helpers/object';\nimport { arrayEach } from './../../../../helpers/array';\nimport { warn } from './../../../../helpers/console';\nimport EventManager from './../../../../eventManager';\nimport Walkontable from './../core';\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay =\n/*#__PURE__*/\nfunction () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n\n  }, {\n    key: \"CLONE_TOP\",\n\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      return new Walkontable({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();\n\nexport default Overlay;"]},"metadata":{},"sourceType":"module"}