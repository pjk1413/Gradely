{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { Parser, ERROR_REF, error as isFormulaError } from 'hot-formula-parser';\nimport { arrayEach, arrayMap } from '../../helpers/array';\nimport localHooks from '../../mixins/localHooks';\nimport { getTranslator } from '../../utils/recordTranslator';\nimport { mixin } from '../../helpers/object';\nimport CellValue from './cell/value';\nimport CellReference from './cell/reference';\nimport { isFormulaExpression, toUpperCaseFormula } from './utils';\nimport Matrix from './matrix';\nimport AlterManager from './alterManager';\nvar STATE_UP_TO_DATE = 1;\nvar STATE_NEED_REBUILD = 2;\nvar STATE_NEED_FULL_REBUILD = 3;\n/**\n * Sheet component responsible for whole spreadsheet calculations.\n *\n * @class Sheet\n * @util\n */\n\nvar Sheet = /*#__PURE__*/function () {\n  function Sheet(hot, dataProvider) {\n    var _this = this;\n\n    _classCallCheck(this, Sheet);\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n\n\n    this.hot = hot;\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n    /**\n     * Data provider for sheet calculations.\n     *\n     * @type {DataProvider}\n     */\n\n    this.dataProvider = dataProvider;\n    /**\n     * Instance of {@link https://github.com/handsontable/formula-parser}.\n     *\n     * @type {Parser}\n     */\n\n    this.parser = new Parser();\n    /**\n     * Instance of {@link Matrix}.\n     *\n     * @type {Matrix}\n     */\n\n    this.matrix = new Matrix(this.t);\n    /**\n     * Instance of {@link AlterManager}.\n     *\n     * @type {AlterManager}\n     */\n\n    this.alterManager = new AlterManager(this);\n    /**\n     * Cell object which indicates which cell is currently processing.\n     *\n     * @private\n     * @type {null}\n     */\n\n    this._processingCell = null;\n    /**\n     * State of the sheet.\n     *\n     * @type {Number}\n     * @private\n     */\n\n    this._state = STATE_NEED_FULL_REBUILD;\n    this.parser.on('callCellValue', function () {\n      return _this._onCallCellValue.apply(_this, arguments);\n    });\n    this.parser.on('callRangeValue', function () {\n      return _this._onCallRangeValue.apply(_this, arguments);\n    });\n    this.alterManager.addLocalHook('afterAlter', function () {\n      return _this._onAfterAlter.apply(_this, arguments);\n    });\n  }\n  /**\n   * Recalculate sheet.\n   */\n\n\n  _createClass(Sheet, [{\n    key: \"recalculate\",\n    value: function recalculate() {\n      switch (this._state) {\n        case STATE_NEED_FULL_REBUILD:\n          this.recalculateFull();\n          break;\n\n        case STATE_NEED_REBUILD:\n          this.recalculateOptimized();\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Recalculate sheet using optimized methods (fast recalculation).\n     */\n\n  }, {\n    key: \"recalculateOptimized\",\n    value: function recalculateOptimized() {\n      var _this2 = this;\n\n      var cells = this.matrix.getOutOfDateCells();\n      arrayEach(cells, function (cellValue) {\n        var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);\n\n        if (isFormulaExpression(value)) {\n          _this2.parseExpression(cellValue, value.substr(1));\n        }\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'optimized');\n    }\n    /**\n     * Recalculate whole table by building dependencies from scratch (slow recalculation).\n     */\n\n  }, {\n    key: \"recalculateFull\",\n    value: function recalculateFull() {\n      var _this3 = this;\n\n      var cells = this.dataProvider.getSourceDataByRange();\n      this.matrix.reset();\n      arrayEach(cells, function (rowData, row) {\n        arrayEach(rowData, function (value, column) {\n          if (isFormulaExpression(value)) {\n            _this3.parseExpression(new CellValue(row, column), value.substr(1));\n          }\n        });\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'full');\n    }\n    /**\n     * Set predefined variable name which can be visible while parsing formula expression.\n     *\n     * @param {String} name Variable name.\n     * @param {*} value Variable value.\n     */\n\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, value) {\n      this.parser.setVariable(name, value);\n    }\n    /**\n     * Get variable name.\n     *\n     * @param {String} name Variable name.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getVariable\",\n    value: function getVariable(name) {\n      return this.parser.getVariable(name);\n    }\n    /**\n     * Apply changes to the sheet.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @param {*} newValue Current cell value.\n     */\n\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(row, column, newValue) {\n      // Remove formula description for old expression\n      // TODO: Move this to recalculate()\n      this.matrix.remove({\n        row: row,\n        column: column\n      }); // TODO: Move this to recalculate()\n\n      if (isFormulaExpression(newValue)) {\n        // ...and create new for new changed formula expression\n        this.parseExpression(new CellValue(row, column), newValue.substr(1));\n      }\n\n      var deps = this.getCellDependencies.apply(this, _toConsumableArray(this.t.toVisual(row, column)));\n      arrayEach(deps, function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n      this._state = STATE_NEED_REBUILD;\n    }\n    /**\n     * Parse and evaluate formula for provided cell.\n     *\n     * @param {CellValue|Object} cellValue Cell value object.\n     * @param {String} formula Value to evaluate.\n     */\n\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(cellValue, formula) {\n      cellValue.setState(CellValue.STATE_COMPUTING);\n      this._processingCell = cellValue;\n\n      var _this$parser$parse = this.parser.parse(toUpperCaseFormula(formula)),\n          error = _this$parser$parse.error,\n          result = _this$parser$parse.result;\n\n      if (isFormulaExpression(result)) {\n        this.parseExpression(cellValue, result.substr(1));\n      } else {\n        cellValue.setValue(result);\n        cellValue.setError(error);\n        cellValue.setState(CellValue.STATE_UP_TO_DATE);\n      }\n\n      this.matrix.add(cellValue);\n      this._processingCell = null;\n    }\n    /**\n     * Get cell value object at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {CellValue|undefined}\n     */\n\n  }, {\n    key: \"getCellAt\",\n    value: function getCellAt(row, column) {\n      return this.matrix.getCellAt(row, column);\n    }\n    /**\n     * Get cell dependencies at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCellDependencies\",\n    value: function getCellDependencies(row, column) {\n      return this.matrix.getDependencies({\n        row: row,\n        column: column\n      });\n    }\n    /**\n     * Listener for parser cell value.\n     *\n     * @private\n     * @param {Object} cellCoords Cell coordinates.\n     * @param {Function} done Function to call with valid cell value.\n     */\n\n  }, {\n    key: \"_onCallCellValue\",\n    value: function _onCallCellValue(_ref, done) {\n      var row = _ref.row,\n          column = _ref.column;\n      var cell = new CellReference(row, column);\n\n      if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {\n        throw Error(ERROR_REF);\n      }\n\n      this.matrix.registerCellRef(cell);\n\n      this._processingCell.addPrecedent(cell);\n\n      var cellValue = this.dataProvider.getRawDataAtCell(row.index, column.index);\n\n      if (isFormulaError(cellValue)) {\n        var computedCell = this.matrix.getCellAt(row.index, column.index);\n\n        if (computedCell && computedCell.hasError()) {\n          throw Error(cellValue);\n        }\n      }\n\n      if (isFormulaExpression(cellValue)) {\n        var _this$parser$parse2 = this.parser.parse(cellValue.substr(1)),\n            error = _this$parser$parse2.error,\n            result = _this$parser$parse2.result;\n\n        if (error) {\n          throw Error(error);\n        }\n\n        done(result);\n      } else {\n        done(cellValue);\n      }\n    }\n    /**\n     * Listener for parser cells (range) value.\n     *\n     * @private\n     * @param {Object} startCell Cell coordinates (top-left corner coordinate).\n     * @param {Object} endCell Cell coordinates (bottom-right corner coordinate).\n     * @param {Function} done Function to call with valid cells values.\n     */\n\n  }, {\n    key: \"_onCallRangeValue\",\n    value: function _onCallRangeValue(_ref2, _ref3, done) {\n      var _this4 = this;\n\n      var startRow = _ref2.row,\n          startColumn = _ref2.column;\n      var endRow = _ref3.row,\n          endColumn = _ref3.column;\n      var cellValues = this.dataProvider.getRawDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index);\n\n      var mapRowData = function mapRowData(rowData, rowIndex) {\n        return arrayMap(rowData, function (cellData, columnIndex) {\n          var rowCellCoord = startRow.index + rowIndex;\n          var columnCellCoord = startColumn.index + columnIndex;\n          var cell = new CellReference(rowCellCoord, columnCellCoord);\n\n          if (!_this4.dataProvider.isInDataRange(cell.row, cell.column)) {\n            throw Error(ERROR_REF);\n          }\n\n          _this4.matrix.registerCellRef(cell);\n\n          _this4._processingCell.addPrecedent(cell);\n\n          var newCellData = cellData;\n\n          if (isFormulaError(newCellData)) {\n            var computedCell = _this4.matrix.getCellAt(cell.row, cell.column);\n\n            if (computedCell && computedCell.hasError()) {\n              throw Error(newCellData);\n            }\n          }\n\n          if (isFormulaExpression(newCellData)) {\n            var _this4$parser$parse = _this4.parser.parse(newCellData.substr(1)),\n                error = _this4$parser$parse.error,\n                result = _this4$parser$parse.result;\n\n            if (error) {\n              throw Error(error);\n            }\n\n            newCellData = result;\n          }\n\n          return newCellData;\n        });\n      };\n\n      var calculatedCellValues = arrayMap(cellValues, function (rowData, rowIndex) {\n        return mapRowData(rowData, rowIndex);\n      });\n      done(calculatedCellValues);\n    }\n    /**\n     * On after alter sheet listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onAfterAlter\",\n    value: function _onAfterAlter() {\n      this.recalculateOptimized();\n    }\n    /**\n     * Destroy class.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.t = null;\n      this.dataProvider.destroy();\n      this.dataProvider = null;\n      this.alterManager.destroy();\n      this.alterManager = null;\n      this.parser = null;\n      this.matrix.reset();\n      this.matrix = null;\n    }\n  }]);\n\n  return Sheet;\n}();\n\nmixin(Sheet, localHooks);\nexport default Sheet;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/formulas/sheet.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Parser","ERROR_REF","error","isFormulaError","arrayEach","arrayMap","localHooks","getTranslator","mixin","CellValue","CellReference","isFormulaExpression","toUpperCaseFormula","Matrix","AlterManager","STATE_UP_TO_DATE","STATE_NEED_REBUILD","STATE_NEED_FULL_REBUILD","Sheet","hot","dataProvider","_this","t","parser","matrix","alterManager","_processingCell","_state","on","_onCallCellValue","apply","arguments","_onCallRangeValue","addLocalHook","_onAfterAlter","value","recalculate","recalculateFull","recalculateOptimized","_this2","cells","getOutOfDateCells","cellValue","getSourceDataAtCell","row","column","parseExpression","substr","runLocalHooks","_this3","getSourceDataByRange","reset","rowData","setVariable","name","getVariable","applyChanges","newValue","remove","deps","getCellDependencies","toVisual","setState","STATE_OUT_OFF_DATE","formula","STATE_COMPUTING","_this$parser$parse","parse","result","setValue","setError","add","getCellAt","getDependencies","_ref","done","cell","isInDataRange","Error","registerCellRef","addPrecedent","getRawDataAtCell","index","computedCell","hasError","_this$parser$parse2","_ref2","_ref3","_this4","startRow","startColumn","endRow","endColumn","cellValues","getRawDataByRange","mapRowData","rowIndex","cellData","columnIndex","rowCellCoord","columnCellCoord","newCellData","_this4$parser$parse","calculatedCellValues","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { Parser, ERROR_REF, error as isFormulaError } from 'hot-formula-parser';\nimport { arrayEach, arrayMap } from '../../helpers/array';\nimport localHooks from '../../mixins/localHooks';\nimport { getTranslator } from '../../utils/recordTranslator';\nimport { mixin } from '../../helpers/object';\nimport CellValue from './cell/value';\nimport CellReference from './cell/reference';\nimport { isFormulaExpression, toUpperCaseFormula } from './utils';\nimport Matrix from './matrix';\nimport AlterManager from './alterManager';\nvar STATE_UP_TO_DATE = 1;\nvar STATE_NEED_REBUILD = 2;\nvar STATE_NEED_FULL_REBUILD = 3;\n/**\n * Sheet component responsible for whole spreadsheet calculations.\n *\n * @class Sheet\n * @util\n */\n\nvar Sheet =\n/*#__PURE__*/\nfunction () {\n  function Sheet(hot, dataProvider) {\n    var _this = this;\n\n    _classCallCheck(this, Sheet);\n\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    this.hot = hot;\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n    /**\n     * Data provider for sheet calculations.\n     *\n     * @type {DataProvider}\n     */\n\n    this.dataProvider = dataProvider;\n    /**\n     * Instance of {@link https://github.com/handsontable/formula-parser}.\n     *\n     * @type {Parser}\n     */\n\n    this.parser = new Parser();\n    /**\n     * Instance of {@link Matrix}.\n     *\n     * @type {Matrix}\n     */\n\n    this.matrix = new Matrix(this.t);\n    /**\n     * Instance of {@link AlterManager}.\n     *\n     * @type {AlterManager}\n     */\n\n    this.alterManager = new AlterManager(this);\n    /**\n     * Cell object which indicates which cell is currently processing.\n     *\n     * @private\n     * @type {null}\n     */\n\n    this._processingCell = null;\n    /**\n     * State of the sheet.\n     *\n     * @type {Number}\n     * @private\n     */\n\n    this._state = STATE_NEED_FULL_REBUILD;\n    this.parser.on('callCellValue', function () {\n      return _this._onCallCellValue.apply(_this, arguments);\n    });\n    this.parser.on('callRangeValue', function () {\n      return _this._onCallRangeValue.apply(_this, arguments);\n    });\n    this.alterManager.addLocalHook('afterAlter', function () {\n      return _this._onAfterAlter.apply(_this, arguments);\n    });\n  }\n  /**\n   * Recalculate sheet.\n   */\n\n\n  _createClass(Sheet, [{\n    key: \"recalculate\",\n    value: function recalculate() {\n      switch (this._state) {\n        case STATE_NEED_FULL_REBUILD:\n          this.recalculateFull();\n          break;\n\n        case STATE_NEED_REBUILD:\n          this.recalculateOptimized();\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Recalculate sheet using optimized methods (fast recalculation).\n     */\n\n  }, {\n    key: \"recalculateOptimized\",\n    value: function recalculateOptimized() {\n      var _this2 = this;\n\n      var cells = this.matrix.getOutOfDateCells();\n      arrayEach(cells, function (cellValue) {\n        var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);\n\n        if (isFormulaExpression(value)) {\n          _this2.parseExpression(cellValue, value.substr(1));\n        }\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'optimized');\n    }\n    /**\n     * Recalculate whole table by building dependencies from scratch (slow recalculation).\n     */\n\n  }, {\n    key: \"recalculateFull\",\n    value: function recalculateFull() {\n      var _this3 = this;\n\n      var cells = this.dataProvider.getSourceDataByRange();\n      this.matrix.reset();\n      arrayEach(cells, function (rowData, row) {\n        arrayEach(rowData, function (value, column) {\n          if (isFormulaExpression(value)) {\n            _this3.parseExpression(new CellValue(row, column), value.substr(1));\n          }\n        });\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'full');\n    }\n    /**\n     * Set predefined variable name which can be visible while parsing formula expression.\n     *\n     * @param {String} name Variable name.\n     * @param {*} value Variable value.\n     */\n\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, value) {\n      this.parser.setVariable(name, value);\n    }\n    /**\n     * Get variable name.\n     *\n     * @param {String} name Variable name.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getVariable\",\n    value: function getVariable(name) {\n      return this.parser.getVariable(name);\n    }\n    /**\n     * Apply changes to the sheet.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @param {*} newValue Current cell value.\n     */\n\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(row, column, newValue) {\n      // Remove formula description for old expression\n      // TODO: Move this to recalculate()\n      this.matrix.remove({\n        row: row,\n        column: column\n      }); // TODO: Move this to recalculate()\n\n      if (isFormulaExpression(newValue)) {\n        // ...and create new for new changed formula expression\n        this.parseExpression(new CellValue(row, column), newValue.substr(1));\n      }\n\n      var deps = this.getCellDependencies.apply(this, _toConsumableArray(this.t.toVisual(row, column)));\n      arrayEach(deps, function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n      this._state = STATE_NEED_REBUILD;\n    }\n    /**\n     * Parse and evaluate formula for provided cell.\n     *\n     * @param {CellValue|Object} cellValue Cell value object.\n     * @param {String} formula Value to evaluate.\n     */\n\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(cellValue, formula) {\n      cellValue.setState(CellValue.STATE_COMPUTING);\n      this._processingCell = cellValue;\n\n      var _this$parser$parse = this.parser.parse(toUpperCaseFormula(formula)),\n          error = _this$parser$parse.error,\n          result = _this$parser$parse.result;\n\n      if (isFormulaExpression(result)) {\n        this.parseExpression(cellValue, result.substr(1));\n      } else {\n        cellValue.setValue(result);\n        cellValue.setError(error);\n        cellValue.setState(CellValue.STATE_UP_TO_DATE);\n      }\n\n      this.matrix.add(cellValue);\n      this._processingCell = null;\n    }\n    /**\n     * Get cell value object at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {CellValue|undefined}\n     */\n\n  }, {\n    key: \"getCellAt\",\n    value: function getCellAt(row, column) {\n      return this.matrix.getCellAt(row, column);\n    }\n    /**\n     * Get cell dependencies at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCellDependencies\",\n    value: function getCellDependencies(row, column) {\n      return this.matrix.getDependencies({\n        row: row,\n        column: column\n      });\n    }\n    /**\n     * Listener for parser cell value.\n     *\n     * @private\n     * @param {Object} cellCoords Cell coordinates.\n     * @param {Function} done Function to call with valid cell value.\n     */\n\n  }, {\n    key: \"_onCallCellValue\",\n    value: function _onCallCellValue(_ref, done) {\n      var row = _ref.row,\n          column = _ref.column;\n      var cell = new CellReference(row, column);\n\n      if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {\n        throw Error(ERROR_REF);\n      }\n\n      this.matrix.registerCellRef(cell);\n\n      this._processingCell.addPrecedent(cell);\n\n      var cellValue = this.dataProvider.getRawDataAtCell(row.index, column.index);\n\n      if (isFormulaError(cellValue)) {\n        var computedCell = this.matrix.getCellAt(row.index, column.index);\n\n        if (computedCell && computedCell.hasError()) {\n          throw Error(cellValue);\n        }\n      }\n\n      if (isFormulaExpression(cellValue)) {\n        var _this$parser$parse2 = this.parser.parse(cellValue.substr(1)),\n            error = _this$parser$parse2.error,\n            result = _this$parser$parse2.result;\n\n        if (error) {\n          throw Error(error);\n        }\n\n        done(result);\n      } else {\n        done(cellValue);\n      }\n    }\n    /**\n     * Listener for parser cells (range) value.\n     *\n     * @private\n     * @param {Object} startCell Cell coordinates (top-left corner coordinate).\n     * @param {Object} endCell Cell coordinates (bottom-right corner coordinate).\n     * @param {Function} done Function to call with valid cells values.\n     */\n\n  }, {\n    key: \"_onCallRangeValue\",\n    value: function _onCallRangeValue(_ref2, _ref3, done) {\n      var _this4 = this;\n\n      var startRow = _ref2.row,\n          startColumn = _ref2.column;\n      var endRow = _ref3.row,\n          endColumn = _ref3.column;\n      var cellValues = this.dataProvider.getRawDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index);\n\n      var mapRowData = function mapRowData(rowData, rowIndex) {\n        return arrayMap(rowData, function (cellData, columnIndex) {\n          var rowCellCoord = startRow.index + rowIndex;\n          var columnCellCoord = startColumn.index + columnIndex;\n          var cell = new CellReference(rowCellCoord, columnCellCoord);\n\n          if (!_this4.dataProvider.isInDataRange(cell.row, cell.column)) {\n            throw Error(ERROR_REF);\n          }\n\n          _this4.matrix.registerCellRef(cell);\n\n          _this4._processingCell.addPrecedent(cell);\n\n          var newCellData = cellData;\n\n          if (isFormulaError(newCellData)) {\n            var computedCell = _this4.matrix.getCellAt(cell.row, cell.column);\n\n            if (computedCell && computedCell.hasError()) {\n              throw Error(newCellData);\n            }\n          }\n\n          if (isFormulaExpression(newCellData)) {\n            var _this4$parser$parse = _this4.parser.parse(newCellData.substr(1)),\n                error = _this4$parser$parse.error,\n                result = _this4$parser$parse.result;\n\n            if (error) {\n              throw Error(error);\n            }\n\n            newCellData = result;\n          }\n\n          return newCellData;\n        });\n      };\n\n      var calculatedCellValues = arrayMap(cellValues, function (rowData, rowIndex) {\n        return mapRowData(rowData, rowIndex);\n      });\n      done(calculatedCellValues);\n    }\n    /**\n     * On after alter sheet listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onAfterAlter\",\n    value: function _onAfterAlter() {\n      this.recalculateOptimized();\n    }\n    /**\n     * Destroy class.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.t = null;\n      this.dataProvider.destroy();\n      this.dataProvider = null;\n      this.alterManager.destroy();\n      this.alterManager = null;\n      this.parser = null;\n      this.matrix.reset();\n      this.matrix = null;\n    }\n  }]);\n\n  return Sheet;\n}();\n\nmixin(Sheet, localHooks);\nexport default Sheet;"]},"metadata":{},"sourceType":"module"}