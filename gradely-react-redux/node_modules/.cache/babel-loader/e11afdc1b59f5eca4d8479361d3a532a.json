{"ast":null,"code":"function _templateObject() {\n  var data = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps with the other declared merged \\n    cell. The overlapping merged cell was not added to the table, please fix your setup.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport MergedCellCoords from './cellCoords';\nimport { CellCoords, CellRange } from '../../3rdparty/walkontable/src/index';\nimport { rangeEach, rangeEachReverse } from '../../helpers/number';\nimport { warn } from '../../helpers/console';\nimport { arrayEach } from '../../helpers/array';\nimport { applySpanProperties } from './utils';\nimport { toSingleLine } from './../../helpers/templateLiteralTag';\n/**\n * Defines a container object for the merged cells.\n *\n * @class MergedCellsCollection\n * @plugin MergeCells\n */\n\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n\n\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @return {String}\n   */\n\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {MergedCellCoords|Boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    value: function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells for.\n     * @return {MergedCellCoords|Boolean}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells in.\n     * @param [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @return {Array|Boolean} Array of found merged cells of `false` if none were found.\n     */\n\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {Object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @return {MergedCellCoords|Boolean} Returns the new merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {MergedCellCoords|Boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\n\n      if (wantedCollection && wantedCollectionIndex !== false) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @return {Boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(null, new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(null, new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a merged parent.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isMergedParent\",\n    value: function isMergedParent(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row === row && mergedCell.col === column) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {String} direction `right`, `left`, `up` or `down`.\n     * @param {Number} index Index where the change, which caused the shifting took place.\n     * @param {Number} count Number of rows/columns added/removed in the preceding action.\n     */\n\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n\n      var shiftVector = [0, 0];\n\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n\n        case 'down':\n          shiftVector[1] += count;\n          break;\n\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n\n        default:\n      }\n\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject(), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n\n  return MergedCellsCollection;\n}();\n\nexport default MergedCellsCollection;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/mergeCells/cellsCollection.js"],"names":["_templateObject","data","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","MergedCellCoords","CellCoords","CellRange","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","plugin","mergedCells","hot","get","row","column","result","mergedCell","rowspan","col","colspan","getByRange","range","to","getWithinRange","countPartials","arguments","undefined","foundMergedCells","testedRange","includesRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","newMergedCell","alreadyExists","isOverlapping","normalize","IS_OVERLAPPING_WARNING","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","_this","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","apply","hiddenCollectionElement","currentRange","isMergedParent","shiftCollections","direction","index","count","_this2","shiftVector","currentMerge","shift","removed"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps with the other declared merged \\n    cell. The overlapping merged cell was not added to the table, please fix your setup.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport MergedCellCoords from './cellCoords';\nimport { CellCoords, CellRange } from '../../3rdparty/walkontable/src/index';\nimport { rangeEach, rangeEachReverse } from '../../helpers/number';\nimport { warn } from '../../helpers/console';\nimport { arrayEach } from '../../helpers/array';\nimport { applySpanProperties } from './utils';\nimport { toSingleLine } from './../../helpers/templateLiteralTag';\n/**\n * Defines a container object for the merged cells.\n *\n * @class MergedCellsCollection\n * @plugin MergeCells\n */\n\nvar MergedCellsCollection =\n/*#__PURE__*/\nfunction () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @return {String}\n   */\n\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {MergedCellCoords|Boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    value: function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells for.\n     * @return {MergedCellCoords|Boolean}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells in.\n     * @param [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @return {Array|Boolean} Array of found merged cells of `false` if none were found.\n     */\n\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {Object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @return {MergedCellCoords|Boolean} Returns the new merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {MergedCellCoords|Boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\n\n      if (wantedCollection && wantedCollectionIndex !== false) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @return {Boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(null, new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(null, new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a merged parent.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isMergedParent\",\n    value: function isMergedParent(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row === row && mergedCell.col === column) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {String} direction `right`, `left`, `up` or `down`.\n     * @param {Number} index Index where the change, which caused the shifting took place.\n     * @param {Number} count Number of rows/columns added/removed in the preceding action.\n     */\n\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n\n      var shiftVector = [0, 0];\n\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n\n        case 'down':\n          shiftVector[1] += count;\n          break;\n\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n\n        default:\n      }\n\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject(), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n\n  return MergedCellsCollection;\n}();\n\nexport default MergedCellsCollection;"]},"metadata":{},"sourceType":"module"}