{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from './constants';\nvar privatePool = new WeakMap();\n/**\n * Calculates indexes of rows to render OR rows that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportRowsCalculator\n */\n\nvar ViewportRowsCalculator = /*#__PURE__*/function () {\n  _createClass(ViewportRowsCalculator, null, [{\n    key: \"DEFAULT_HEIGHT\",\n\n    /**\n     * Default row height\n     *\n     * @type {Number}\n     */\n    get: function get() {\n      return 23;\n    }\n    /**\n     * @param {Object} options Object with all options specyfied for row viewport calculation.\n     * @param {Number} options.viewportHeight Height of the viewport\n     * @param {Number} options.scrollOffset Current vertical scroll position of the viewport\n     * @param {Number} options.totalRows Total number of rows\n     * @param {Function} options.rowHeightFn Function that returns the height of the row at a given index (in px)\n     * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)\n     * @param {String} options.calculationType String which describes types of calculation which will be performed.\n     * @param {Number} options.horizontalScrollbarHeight\n     */\n\n  }]);\n\n  function ViewportRowsCalculator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        viewportSize = _ref.viewportSize,\n        scrollOffset = _ref.scrollOffset,\n        totalItems = _ref.totalItems,\n        itemSizeFn = _ref.itemSizeFn,\n        overrideFn = _ref.overrideFn,\n        calculationType = _ref.calculationType,\n        scrollbarHeight = _ref.scrollbarHeight;\n\n    _classCallCheck(this, ViewportRowsCalculator);\n\n    privatePool.set(this, {\n      viewportHeight: viewportSize,\n      scrollOffset: scrollOffset,\n      totalRows: totalItems,\n      rowHeightFn: itemSizeFn,\n      overrideFn: overrideFn,\n      calculationType: calculationType,\n      horizontalScrollbarHeight: scrollbarHeight\n    });\n    /**\n     * Number of rendered/visible rows\n     *\n     * @type {Number}\n     */\n\n    this.count = 0;\n    /**\n     * Index of the first rendered/visible row (can be overwritten using overrideFn)\n     *\n     * @type {Number|null}\n     */\n\n    this.startRow = null;\n    /**\n     * Index of the last rendered/visible row (can be overwritten using overrideFn)\n     *\n     * @type {null}\n     */\n\n    this.endRow = null;\n    /**\n     * Position of the first rendered/visible row (in px)\n     *\n     * @type {Number|null}\n     */\n\n    this.startPosition = null;\n    this.calculate();\n  }\n  /**\n   * Calculates viewport\n   */\n\n\n  _createClass(ViewportRowsCalculator, [{\n    key: \"calculate\",\n    value: function calculate() {\n      var sum = 0;\n      var needReverse = true;\n      var startPositions = [];\n      var priv = privatePool.get(this);\n      var calculationType = priv.calculationType;\n      var overrideFn = priv.overrideFn;\n      var rowHeightFn = priv.rowHeightFn;\n      var scrollOffset = priv.scrollOffset;\n      var totalRows = priv.totalRows;\n      var viewportHeight = priv.viewportHeight;\n      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;\n      var rowHeight; // Calculate the number (start and end index) of rows needed\n\n      for (var i = 0; i < totalRows; i++) {\n        rowHeight = rowHeightFn(i);\n\n        if (isNaN(rowHeight)) {\n          rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\n        }\n\n        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow = i;\n        }\n\n        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          if (this.startRow === null) {\n            this.startRow = i;\n          }\n\n          this.endRow = i;\n        }\n\n        startPositions.push(sum);\n        sum += rowHeight;\n\n        if (calculationType !== FULLY_VISIBLE_TYPE) {\n          this.endRow = i;\n        }\n\n        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          needReverse = false;\n          break;\n        }\n      } // If the estimation has reached the last row and there is still some space available in the viewport,\n      // we need to render in reverse in order to fill the whole viewport with rows\n\n\n      if (this.endRow === totalRows - 1 && needReverse) {\n        this.startRow = this.endRow;\n\n        while (this.startRow > 0) {\n          // rowHeight is the height of the last row\n          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n\n          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\n            this.startRow -= 1;\n          }\n\n          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\n            break;\n          }\n        }\n      }\n\n      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\n        overrideFn(this);\n      }\n\n      this.startPosition = startPositions[this.startRow];\n\n      if (this.startPosition === void 0) {\n        this.startPosition = null;\n      } // If totalRows exceeded its total rows size set endRow to the latest item\n\n\n      if (totalRows < this.endRow) {\n        this.endRow = totalRows - 1;\n      }\n\n      if (this.startRow !== null) {\n        this.count = this.endRow - this.startRow + 1;\n      }\n    }\n  }]);\n\n  return ViewportRowsCalculator;\n}();\n\nexport default ViewportRowsCalculator;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/3rdparty/walkontable/src/calculator/viewportRows.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","RENDER_TYPE","FULLY_VISIBLE_TYPE","privatePool","WeakMap","ViewportRowsCalculator","get","_ref","arguments","undefined","viewportSize","scrollOffset","totalItems","itemSizeFn","overrideFn","calculationType","scrollbarHeight","set","viewportHeight","totalRows","rowHeightFn","horizontalScrollbarHeight","count","startRow","endRow","startPosition","calculate","value","sum","needReverse","startPositions","priv","rowHeight","isNaN","DEFAULT_HEIGHT","push","viewportSum"],"mappings":"AAMA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,SAASkB,WAAT,EAAsBC,kBAAtB,QAAgD,aAAhD;AACA,IAAIC,WAAW,GAAG,IAAIC,OAAJ,EAAlB;AACA;;;;;;;AAOA,IAAIC,sBAAsB,GAC1B,aACA,YAAY;AACVR,EAAAA,YAAY,CAACQ,sBAAD,EAAyB,IAAzB,EAA+B,CAAC;AAC1CT,IAAAA,GAAG,EAAE,gBADqC;;AAG1C;;;;;AAKAU,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,EAAP;AACD;AACD;;;;;;;;;;;AAX0C,GAAD,CAA/B,CAAZ;;AAwBA,WAASD,sBAAT,GAAkC;AAChC,QAAIE,IAAI,GAAGC,SAAS,CAACnB,MAAV,GAAmB,CAAnB,IAAwBmB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AAAA,QACIE,YAAY,GAAGH,IAAI,CAACG,YADxB;AAAA,QAEIC,YAAY,GAAGJ,IAAI,CAACI,YAFxB;AAAA,QAGIC,UAAU,GAAGL,IAAI,CAACK,UAHtB;AAAA,QAIIC,UAAU,GAAGN,IAAI,CAACM,UAJtB;AAAA,QAKIC,UAAU,GAAGP,IAAI,CAACO,UALtB;AAAA,QAMIC,eAAe,GAAGR,IAAI,CAACQ,eAN3B;AAAA,QAOIC,eAAe,GAAGT,IAAI,CAACS,eAP3B;;AASAnC,IAAAA,eAAe,CAAC,IAAD,EAAOwB,sBAAP,CAAf;;AAEAF,IAAAA,WAAW,CAACc,GAAZ,CAAgB,IAAhB,EAAsB;AACpBC,MAAAA,cAAc,EAAER,YADI;AAEpBC,MAAAA,YAAY,EAAEA,YAFM;AAGpBQ,MAAAA,SAAS,EAAEP,UAHS;AAIpBQ,MAAAA,WAAW,EAAEP,UAJO;AAKpBC,MAAAA,UAAU,EAAEA,UALQ;AAMpBC,MAAAA,eAAe,EAAEA,eANG;AAOpBM,MAAAA,yBAAyB,EAAEL;AAPP,KAAtB;AASA;;;;;;AAMA,SAAKM,KAAL,GAAa,CAAb;AACA;;;;;;AAMA,SAAKC,QAAL,GAAgB,IAAhB;AACA;;;;;;AAMA,SAAKC,MAAL,GAAc,IAAd;AACA;;;;;;AAMA,SAAKC,aAAL,GAAqB,IAArB;AACA,SAAKC,SAAL;AACD;AACD;;;;;AAKA7B,EAAAA,YAAY,CAACQ,sBAAD,EAAyB,CAAC;AACpCT,IAAAA,GAAG,EAAE,WAD+B;AAEpC+B,IAAAA,KAAK,EAAE,SAASD,SAAT,GAAqB;AAC1B,UAAIE,GAAG,GAAG,CAAV;AACA,UAAIC,WAAW,GAAG,IAAlB;AACA,UAAIC,cAAc,GAAG,EAArB;AACA,UAAIC,IAAI,GAAG5B,WAAW,CAACG,GAAZ,CAAgB,IAAhB,CAAX;AACA,UAAIS,eAAe,GAAGgB,IAAI,CAAChB,eAA3B;AACA,UAAID,UAAU,GAAGiB,IAAI,CAACjB,UAAtB;AACA,UAAIM,WAAW,GAAGW,IAAI,CAACX,WAAvB;AACA,UAAIT,YAAY,GAAGoB,IAAI,CAACpB,YAAxB;AACA,UAAIQ,SAAS,GAAGY,IAAI,CAACZ,SAArB;AACA,UAAID,cAAc,GAAGa,IAAI,CAACb,cAA1B;AACA,UAAIG,yBAAyB,GAAGU,IAAI,CAACV,yBAAL,IAAkC,CAAlE;AACA,UAAIW,SAAJ,CAZ0B,CAYX;;AAEf,WAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,SAApB,EAA+B/B,CAAC,EAAhC,EAAoC;AAClC4C,QAAAA,SAAS,GAAGZ,WAAW,CAAChC,CAAD,CAAvB;;AAEA,YAAI6C,KAAK,CAACD,SAAD,CAAT,EAAsB;AACpBA,UAAAA,SAAS,GAAG3B,sBAAsB,CAAC6B,cAAnC;AACD;;AAED,YAAIN,GAAG,IAAIjB,YAAP,IAAuBI,eAAe,KAAKb,kBAA/C,EAAmE;AACjE,eAAKqB,QAAL,GAAgBnC,CAAhB;AACD;;AAED,YAAIwC,GAAG,IAAIjB,YAAP,IAAuBiB,GAAG,IAAIb,eAAe,KAAKb,kBAApB,GAAyC8B,SAAzC,GAAqD,CAAzD,CAAH,IAAkErB,YAAY,GAAGO,cAAf,GAAgCG,yBAA7H,EAAwJ;AACtJ,cAAI,KAAKE,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,iBAAKA,QAAL,GAAgBnC,CAAhB;AACD;;AAED,eAAKoC,MAAL,GAAcpC,CAAd;AACD;;AAED0C,QAAAA,cAAc,CAACK,IAAf,CAAoBP,GAApB;AACAA,QAAAA,GAAG,IAAII,SAAP;;AAEA,YAAIjB,eAAe,KAAKb,kBAAxB,EAA4C;AAC1C,eAAKsB,MAAL,GAAcpC,CAAd;AACD;;AAED,YAAIwC,GAAG,IAAIjB,YAAY,GAAGO,cAAf,GAAgCG,yBAA3C,EAAsE;AACpEQ,UAAAA,WAAW,GAAG,KAAd;AACA;AACD;AACF,OA5CyB,CA4CxB;AACF;;;AAGA,UAAI,KAAKL,MAAL,KAAgBL,SAAS,GAAG,CAA5B,IAAiCU,WAArC,EAAkD;AAChD,aAAKN,QAAL,GAAgB,KAAKC,MAArB;;AAEA,eAAO,KAAKD,QAAL,GAAgB,CAAvB,EAA0B;AACxB;AACA,cAAIa,WAAW,GAAGN,cAAc,CAAC,KAAKN,MAAN,CAAd,GAA8BQ,SAA9B,GAA0CF,cAAc,CAAC,KAAKP,QAAL,GAAgB,CAAjB,CAA1E;;AAEA,cAAIa,WAAW,IAAIlB,cAAc,GAAGG,yBAAhC,IAA6DN,eAAe,KAAKb,kBAArF,EAAyG;AACvG,iBAAKqB,QAAL,IAAiB,CAAjB;AACD;;AAED,cAAIa,WAAW,IAAIlB,cAAc,GAAGG,yBAApC,EAA+D;AAC7D;AACD;AACF;AACF;;AAED,UAAIN,eAAe,KAAKd,WAApB,IAAmC,KAAKsB,QAAL,KAAkB,IAArD,IAA6DT,UAAjE,EAA6E;AAC3EA,QAAAA,UAAU,CAAC,IAAD,CAAV;AACD;;AAED,WAAKW,aAAL,GAAqBK,cAAc,CAAC,KAAKP,QAAN,CAAnC;;AAEA,UAAI,KAAKE,aAAL,KAAuB,KAAK,CAAhC,EAAmC;AACjC,aAAKA,aAAL,GAAqB,IAArB;AACD,OAzEyB,CAyExB;;;AAGF,UAAIN,SAAS,GAAG,KAAKK,MAArB,EAA6B;AAC3B,aAAKA,MAAL,GAAcL,SAAS,GAAG,CAA1B;AACD;;AAED,UAAI,KAAKI,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,aAAKD,KAAL,GAAa,KAAKE,MAAL,GAAc,KAAKD,QAAnB,GAA8B,CAA3C;AACD;AACF;AArFmC,GAAD,CAAzB,CAAZ;;AAwFA,SAAOlB,sBAAP;AACD,CA1KD,EAFA;;AA8KA,eAAeA,sBAAf","sourcesContent":["import \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.weak-map\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from './constants';\nvar privatePool = new WeakMap();\n/**\n * Calculates indexes of rows to render OR rows that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportRowsCalculator\n */\n\nvar ViewportRowsCalculator =\n/*#__PURE__*/\nfunction () {\n  _createClass(ViewportRowsCalculator, null, [{\n    key: \"DEFAULT_HEIGHT\",\n\n    /**\n     * Default row height\n     *\n     * @type {Number}\n     */\n    get: function get() {\n      return 23;\n    }\n    /**\n     * @param {Object} options Object with all options specyfied for row viewport calculation.\n     * @param {Number} options.viewportHeight Height of the viewport\n     * @param {Number} options.scrollOffset Current vertical scroll position of the viewport\n     * @param {Number} options.totalRows Total number of rows\n     * @param {Function} options.rowHeightFn Function that returns the height of the row at a given index (in px)\n     * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)\n     * @param {String} options.calculationType String which describes types of calculation which will be performed.\n     * @param {Number} options.horizontalScrollbarHeight\n     */\n\n  }]);\n\n  function ViewportRowsCalculator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        viewportSize = _ref.viewportSize,\n        scrollOffset = _ref.scrollOffset,\n        totalItems = _ref.totalItems,\n        itemSizeFn = _ref.itemSizeFn,\n        overrideFn = _ref.overrideFn,\n        calculationType = _ref.calculationType,\n        scrollbarHeight = _ref.scrollbarHeight;\n\n    _classCallCheck(this, ViewportRowsCalculator);\n\n    privatePool.set(this, {\n      viewportHeight: viewportSize,\n      scrollOffset: scrollOffset,\n      totalRows: totalItems,\n      rowHeightFn: itemSizeFn,\n      overrideFn: overrideFn,\n      calculationType: calculationType,\n      horizontalScrollbarHeight: scrollbarHeight\n    });\n    /**\n     * Number of rendered/visible rows\n     *\n     * @type {Number}\n     */\n\n    this.count = 0;\n    /**\n     * Index of the first rendered/visible row (can be overwritten using overrideFn)\n     *\n     * @type {Number|null}\n     */\n\n    this.startRow = null;\n    /**\n     * Index of the last rendered/visible row (can be overwritten using overrideFn)\n     *\n     * @type {null}\n     */\n\n    this.endRow = null;\n    /**\n     * Position of the first rendered/visible row (in px)\n     *\n     * @type {Number|null}\n     */\n\n    this.startPosition = null;\n    this.calculate();\n  }\n  /**\n   * Calculates viewport\n   */\n\n\n  _createClass(ViewportRowsCalculator, [{\n    key: \"calculate\",\n    value: function calculate() {\n      var sum = 0;\n      var needReverse = true;\n      var startPositions = [];\n      var priv = privatePool.get(this);\n      var calculationType = priv.calculationType;\n      var overrideFn = priv.overrideFn;\n      var rowHeightFn = priv.rowHeightFn;\n      var scrollOffset = priv.scrollOffset;\n      var totalRows = priv.totalRows;\n      var viewportHeight = priv.viewportHeight;\n      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;\n      var rowHeight; // Calculate the number (start and end index) of rows needed\n\n      for (var i = 0; i < totalRows; i++) {\n        rowHeight = rowHeightFn(i);\n\n        if (isNaN(rowHeight)) {\n          rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\n        }\n\n        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow = i;\n        }\n\n        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          if (this.startRow === null) {\n            this.startRow = i;\n          }\n\n          this.endRow = i;\n        }\n\n        startPositions.push(sum);\n        sum += rowHeight;\n\n        if (calculationType !== FULLY_VISIBLE_TYPE) {\n          this.endRow = i;\n        }\n\n        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {\n          needReverse = false;\n          break;\n        }\n      } // If the estimation has reached the last row and there is still some space available in the viewport,\n      // we need to render in reverse in order to fill the whole viewport with rows\n\n\n      if (this.endRow === totalRows - 1 && needReverse) {\n        this.startRow = this.endRow;\n\n        while (this.startRow > 0) {\n          // rowHeight is the height of the last row\n          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n\n          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\n            this.startRow -= 1;\n          }\n\n          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\n            break;\n          }\n        }\n      }\n\n      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\n        overrideFn(this);\n      }\n\n      this.startPosition = startPositions[this.startRow];\n\n      if (this.startPosition === void 0) {\n        this.startPosition = null;\n      } // If totalRows exceeded its total rows size set endRow to the latest item\n\n\n      if (totalRows < this.endRow) {\n        this.endRow = totalRows - 1;\n      }\n\n      if (this.startRow !== null) {\n        this.count = this.endRow - this.startRow + 1;\n      }\n    }\n  }]);\n\n  return ViewportRowsCalculator;\n}();\n\nexport default ViewportRowsCalculator;"]},"metadata":{},"sourceType":"module"}