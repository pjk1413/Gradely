{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { addClass, hasClass } from './../../../helpers/dom/element';\nimport Border from './border';\nimport CellCoords from './cell/coords';\nimport CellRange from './cell/range';\n/**\n * @class Selection\n */\n\nvar Selection = /*#__PURE__*/function () {\n  /**\n   * @param {Object} settings\n   * @param {CellRange} cellRange\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance\n   *\n   * @param {Walkontable} wotInstance\n   * @returns {Border}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection\n     *\n     * @param {CellCoords} coords\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success\n     *\n     * @param {CellCoords} oldCoords\n     * @param {CellCoords} newCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Clears selection\n     *\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getTopLeftCorner();\n      var bottomRight = this.cellRange.getBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords\n     *\n     * @param {Walkontable} wotInstance Walkontable instance\n     * @param {Number} sourceRow Cell row coord\n     * @param {Number} sourceColumn Cell column coord\n     * @param {String} className Class name\n     * @param {Boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n\n        addClass(TD, cellClassName);\n      }\n\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');\n     *\n     * @param {String} baseClassName Base className to be used.\n     * @param {Number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @return {Function}\n     */\n\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n\n        return className;\n      };\n    }\n    /**\n     * @param wotInstance\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n\n        return;\n      }\n\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n\n      var _corners = _slicedToArray(corners, 4),\n          topRow = _corners[0],\n          topColumn = _corners[1],\n          bottomRow = _corners[2],\n          bottomColumn = _corners[3];\n\n      for (var column = 0; column < renderedColumns; column += 1) {\n        var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n\n        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n          var TH = wotInstance.wtTable.getColumnHeader(sourceCol);\n\n          if (TH) {\n            var newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightColumnClassName) {\n              newClasses.push(this.settings.highlightColumnClassName);\n            }\n\n            addClass(TH, newClasses);\n          }\n        }\n      }\n\n      for (var row = 0; row < renderedRows; row += 1) {\n        var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n\n        if (sourceRow >= topRow && sourceRow <= bottomRow) {\n          var _TH = wotInstance.wtTable.getRowHeader(sourceRow);\n\n          if (_TH) {\n            var _newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              _newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightRowClassName) {\n              _newClasses.push(this.settings.highlightRowClassName);\n            }\n\n            addClass(_TH, _newClasses);\n          }\n        }\n\n        for (var _column = 0; _column < renderedColumns; _column += 1) {\n          var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n\n          if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selected cell\n            if (this.settings.className) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n            }\n          } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n            // selection is in this row\n            if (this.settings.highlightRowClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightRowClassName);\n            }\n          } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selection is in this column\n            if (this.settings.highlightColumnClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightColumnClassName);\n            }\n          }\n\n          var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, corners, this.settings.layerLevel);\n\n          if (typeof additionalSelectionClass === 'string') {\n            this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n          }\n        }\n      }\n\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport default Selection;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/3rdparty/walkontable/src/selection.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_typeof","obj","constructor","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","addClass","hasClass","Border","CellCoords","CellRange","Selection","settings","cellRange","instanceBorders","classNames","className","classNameGenerator","linearClassNameGenerator","layerLevel","getBorder","wotInstance","guid","isEmpty","add","coords","expand","replace","oldCoords","newCoords","from","isEqual","to","clear","getCorners","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","row","col","addClassAtCoords","sourceRow","sourceColumn","markIntersections","arguments","TD","wtTable","getCell","cellClassName","includes","baseClassName","layerLevelOwner","calcClassName","element","previousIndex","index","previousClassName","concat","currentLayer","draw","border","disappear","renderedRows","getRenderedRowsCount","renderedColumns","getRenderedColumnsCount","corners","_corners","topRow","topColumn","bottomRow","bottomColumn","column","sourceCol","columnFilter","renderedToSource","TH","getColumnHeader","newClasses","highlightHeaderClassName","highlightColumnClassName","rowFilter","_TH","getRowHeader","_newClasses","highlightRowClassName","_column","_sourceCol","additionalSelectionClass","getSetting","appear","destroy","values","forEach"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.object.values\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { addClass, hasClass } from './../../../helpers/dom/element';\nimport Border from './border';\nimport CellCoords from './cell/coords';\nimport CellRange from './cell/range';\n/**\n * @class Selection\n */\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} settings\n   * @param {CellRange} cellRange\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance\n   *\n   * @param {Walkontable} wotInstance\n   * @returns {Border}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection\n     *\n     * @param {CellCoords} coords\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success\n     *\n     * @param {CellCoords} oldCoords\n     * @param {CellCoords} newCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Clears selection\n     *\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getTopLeftCorner();\n      var bottomRight = this.cellRange.getBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords\n     *\n     * @param {Walkontable} wotInstance Walkontable instance\n     * @param {Number} sourceRow Cell row coord\n     * @param {Number} sourceColumn Cell column coord\n     * @param {String} className Class name\n     * @param {Boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n\n        addClass(TD, cellClassName);\n      }\n\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');\n     *\n     * @param {String} baseClassName Base className to be used.\n     * @param {Number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @return {Function}\n     */\n\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n\n        return className;\n      };\n    }\n    /**\n     * @param wotInstance\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n\n        return;\n      }\n\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n\n      var _corners = _slicedToArray(corners, 4),\n          topRow = _corners[0],\n          topColumn = _corners[1],\n          bottomRow = _corners[2],\n          bottomColumn = _corners[3];\n\n      for (var column = 0; column < renderedColumns; column += 1) {\n        var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n\n        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n          var TH = wotInstance.wtTable.getColumnHeader(sourceCol);\n\n          if (TH) {\n            var newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightColumnClassName) {\n              newClasses.push(this.settings.highlightColumnClassName);\n            }\n\n            addClass(TH, newClasses);\n          }\n        }\n      }\n\n      for (var row = 0; row < renderedRows; row += 1) {\n        var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n\n        if (sourceRow >= topRow && sourceRow <= bottomRow) {\n          var _TH = wotInstance.wtTable.getRowHeader(sourceRow);\n\n          if (_TH) {\n            var _newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              _newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightRowClassName) {\n              _newClasses.push(this.settings.highlightRowClassName);\n            }\n\n            addClass(_TH, _newClasses);\n          }\n        }\n\n        for (var _column = 0; _column < renderedColumns; _column += 1) {\n          var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n\n          if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selected cell\n            if (this.settings.className) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n            }\n          } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n            // selection is in this row\n            if (this.settings.highlightRowClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightRowClassName);\n            }\n          } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selection is in this column\n            if (this.settings.highlightColumnClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightColumnClassName);\n            }\n          }\n\n          var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, corners, this.settings.layerLevel);\n\n          if (typeof additionalSelectionClass === 'string') {\n            this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n          }\n        }\n      }\n\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport default Selection;"]},"metadata":{},"sourceType":"module"}