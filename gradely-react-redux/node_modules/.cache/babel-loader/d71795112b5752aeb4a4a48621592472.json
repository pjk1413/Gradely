{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n/**\n * Immutable interface for Matrices\n *\n * @todo use Types.Point for all point references\n *\n * \n */\n\nimport { range as _range } from \"./util\";\nimport * as Types from \"./types\";\n/** Gets the value at row and column of matrix. */\n\nexport function get(row, column, matrix) {\n  var columns = matrix[row];\n\n  if (columns === undefined) {\n    return undefined;\n  }\n\n  return columns[column];\n}\n/** Creates a slice of matrix from startPoint up to, but not including, endPoint. */\n\nexport function slice(startPoint, endPoint, matrix) {\n  var sliced = [];\n  var columns = endPoint.column - startPoint.column;\n\n  for (var row = startPoint.row; row <= endPoint.row; row++) {\n    var slicedRow = row - startPoint.row;\n    sliced[slicedRow] = sliced[slicedRow] || Array(columns);\n\n    for (var column = startPoint.column; column <= endPoint.column; column++) {\n      sliced[slicedRow][column - startPoint.column] = get(row, column, matrix);\n    }\n  }\n\n  return sliced;\n}\n/** Sets the value at row and column of matrix. If a row doesn't exist, it's created. */\n\nexport function set(row, column, value, matrix) {\n  var nextMatrix = _toConsumableArray(matrix); // Synchronize first row length\n\n\n  var firstRow = matrix[0];\n  var nextFirstRow = firstRow ? _toConsumableArray(firstRow) : [];\n\n  if (nextFirstRow.length - 1 < column) {\n    nextFirstRow[column] = undefined;\n    nextMatrix[0] = nextFirstRow;\n  }\n\n  var nextRow = matrix[row] ? _toConsumableArray(matrix[row]) : [];\n  nextRow[column] = value;\n  nextMatrix[row] = nextRow;\n  return nextMatrix;\n}\n/** Like Matrix.set() but mutates the matrix */\n\nexport function mutableSet(row, column, value, matrix) {\n  var firstRow = matrix[0];\n\n  if (!firstRow) {\n    firstRow = [];\n    matrix[0] = firstRow;\n  }\n\n  if (!(row in matrix)) {\n    matrix[row] = [];\n  } // Synchronize first row length\n\n\n  if (!(column in firstRow)) {\n    firstRow[column] = undefined;\n  }\n\n  matrix[row][column] = value;\n}\n/** Removes the coordinate of matrix */\n\nexport function unset(row, column, matrix) {\n  if (!has(row, column, matrix)) {\n    return matrix;\n  }\n\n  var nextMatrix = _toConsumableArray(matrix);\n\n  var nextRow = _toConsumableArray(matrix[row]); // Avoid deleting to preserve first row length\n\n\n  nextRow[column] = undefined;\n  nextMatrix[row] = nextRow;\n  return nextMatrix;\n}\nexport function reduce(func, matrix, initialValue) {\n  var _getSize = getSize(matrix),\n      rows = _getSize.rows,\n      columns = _getSize.columns;\n\n  var acc = initialValue;\n\n  for (var row = 0; row < rows; row++) {\n    if (!matrix[row]) {\n      continue;\n    }\n\n    for (var column = 0; column < columns; column++) {\n      if (column in matrix[row]) {\n        acc = func(acc, matrix[row][column], {\n          row: row,\n          column: column\n        });\n      }\n    }\n  }\n\n  return acc;\n}\n/** Creates an array of values by running each element in collection thru iteratee. */\n\nexport function map(func, matrix) {\n  return reduce(function (acc, value, point) {\n    mutableSet(point.row, point.column, func(value, point), acc);\n    return acc;\n  }, matrix, []);\n}\n/**\n * Converts all elements in row into a string separated by horizontalSeparator and each row string\n * to string separated by verticalSeparator\n */\n\nexport function join(matrix) {\n  var horizontalSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\\t\";\n  var verticalSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n  var joined = \"\";\n\n  var _getSize2 = getSize(matrix),\n      rows = _getSize2.rows,\n      columns = _getSize2.columns;\n\n  for (var row = 0; row < rows; row++) {\n    if (row) {\n      joined += verticalSeparator;\n    }\n\n    for (var column = 0; column < columns; column++) {\n      if (column) {\n        joined += horizontalSeparator;\n      }\n\n      if (matrix[row] && column in matrix[row]) {\n        joined += String(matrix[row][column]);\n      }\n    }\n  }\n\n  return joined;\n}\n/* Parses a CSV separated by a horizontalSeparator and verticalSeparator into a Matrix */\n\nexport function split(csv, getValue) {\n  var horizontalSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\t\";\n  var verticalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : /\\r\\n|\\n|\\r/;\n  return csv.split(verticalSeparator).map(function (row) {\n    return row.split(horizontalSeparator).map(getValue);\n  });\n}\n/** Returns whether the point exists in the matrix or not. */\n\nexport function has(row, column, matrix) {\n  var firstRow = matrix[0];\n  return firstRow && // validation\n  row >= 0 && column >= 0 && Number.isInteger(row) && Number.isInteger(column) && // first row length is in sync with other rows\n  column < firstRow.length && row < matrix.length;\n}\n/** Gets the size of matrix by returning its number of rows and columns */\n\nexport function getSize(matrix) {\n  var firstRow = matrix[0];\n  return {\n    columns: firstRow ? firstRow.length : 0,\n    rows: matrix.length\n  };\n}\nexport function padMatrix(matrix, desiredRows) {\n  var _getSize3 = getSize(matrix),\n      rows = _getSize3.rows;\n\n  var missingRows = desiredRows - rows;\n  if (rows === 0 || missingRows < 0) return matrix;\n  var paddingRow = matrix.slice(-1)[0].map(function (v) {\n    return _objectSpread({}, v, {\n      value: \"\"\n    });\n  });\n  return [].concat(_toConsumableArray(matrix), _toConsumableArray(Array(missingRows).fill(paddingRow)));\n}\n/** Creates an array of points (positive and/or negative) progressing from startPoint up to, but not including, endPoint. */\n\nexport function range(endPoint, startPoint) {\n  var points = [];\n  var columnsRange = startPoint.column !== endPoint.column ? _range(endPoint.column, startPoint.column) : startPoint.row !== endPoint.row ? [startPoint.column] : [];\n  var rowsRange = startPoint.row !== endPoint.row ? _range(endPoint.row, startPoint.row) : startPoint.column !== endPoint.column ? [startPoint.row] : [];\n\n  for (var i = 0; i < rowsRange.length; i++) {\n    var row = rowsRange[i];\n\n    for (var j = 0; j < columnsRange.length; j++) {\n      var column = columnsRange[j];\n      points.push({\n        row: row,\n        column: column\n      });\n    }\n  }\n\n  return points;\n}\n/** Like Matrix.range() but including endPoint. */\n\nexport var inclusiveRange = function inclusiveRange(endPoint, startPoint) {\n  return range({\n    row: endPoint.row + Math.sign(endPoint.row - startPoint.row),\n    column: endPoint.column + Math.sign(endPoint.column - startPoint.column)\n  }, startPoint);\n};\nexport function toArray(matrix, transform) {\n  var array = [];\n\n  for (var row = 0; row < matrix.length; row++) {\n    for (var column = 0; column < matrix.length; column++) {\n      var _value = matrix[row][column];\n      array.push(transform ? transform(_value) : _value);\n    }\n  }\n\n  return array;\n}","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/react-spreadsheet/dist/matrix.js"],"names":["_objectSpread","_toConsumableArray","range","_range","Types","get","row","column","matrix","columns","undefined","slice","startPoint","endPoint","sliced","slicedRow","Array","set","value","nextMatrix","firstRow","nextFirstRow","length","nextRow","mutableSet","unset","has","reduce","func","initialValue","_getSize","getSize","rows","acc","map","point","join","horizontalSeparator","arguments","verticalSeparator","joined","_getSize2","String","split","csv","getValue","Number","isInteger","padMatrix","desiredRows","_getSize3","missingRows","paddingRow","v","concat","fill","points","columnsRange","rowsRange","i","j","push","inclusiveRange","Math","sign","toArray","transform","array","_value"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * Immutable interface for Matrices\n *\n * @todo use Types.Point for all point references\n *\n * \n */\nimport { range as _range } from \"./util\";\nimport * as Types from \"./types\";\n\n/** Gets the value at row and column of matrix. */\nexport function get(row, column, matrix) {\n  var columns = matrix[row];\n\n  if (columns === undefined) {\n    return undefined;\n  }\n\n  return columns[column];\n}\n/** Creates a slice of matrix from startPoint up to, but not including, endPoint. */\n\nexport function slice(startPoint, endPoint, matrix) {\n  var sliced = [];\n  var columns = endPoint.column - startPoint.column;\n\n  for (var row = startPoint.row; row <= endPoint.row; row++) {\n    var slicedRow = row - startPoint.row;\n    sliced[slicedRow] = sliced[slicedRow] || Array(columns);\n\n    for (var column = startPoint.column; column <= endPoint.column; column++) {\n      sliced[slicedRow][column - startPoint.column] = get(row, column, matrix);\n    }\n  }\n\n  return sliced;\n}\n/** Sets the value at row and column of matrix. If a row doesn't exist, it's created. */\n\nexport function set(row, column, value, matrix) {\n  var nextMatrix = _toConsumableArray(matrix); // Synchronize first row length\n\n\n  var firstRow = matrix[0];\n  var nextFirstRow = firstRow ? _toConsumableArray(firstRow) : [];\n\n  if (nextFirstRow.length - 1 < column) {\n    nextFirstRow[column] = undefined;\n    nextMatrix[0] = nextFirstRow;\n  }\n\n  var nextRow = matrix[row] ? _toConsumableArray(matrix[row]) : [];\n  nextRow[column] = value;\n  nextMatrix[row] = nextRow;\n  return nextMatrix;\n}\n/** Like Matrix.set() but mutates the matrix */\n\nexport function mutableSet(row, column, value, matrix) {\n  var firstRow = matrix[0];\n\n  if (!firstRow) {\n    firstRow = [];\n    matrix[0] = firstRow;\n  }\n\n  if (!(row in matrix)) {\n    matrix[row] = [];\n  } // Synchronize first row length\n\n\n  if (!(column in firstRow)) {\n    firstRow[column] = undefined;\n  }\n\n  matrix[row][column] = value;\n}\n/** Removes the coordinate of matrix */\n\nexport function unset(row, column, matrix) {\n  if (!has(row, column, matrix)) {\n    return matrix;\n  }\n\n  var nextMatrix = _toConsumableArray(matrix);\n\n  var nextRow = _toConsumableArray(matrix[row]); // Avoid deleting to preserve first row length\n\n\n  nextRow[column] = undefined;\n  nextMatrix[row] = nextRow;\n  return nextMatrix;\n}\nexport function reduce(func, matrix, initialValue) {\n  var _getSize = getSize(matrix),\n      rows = _getSize.rows,\n      columns = _getSize.columns;\n\n  var acc = initialValue;\n\n  for (var row = 0; row < rows; row++) {\n    if (!matrix[row]) {\n      continue;\n    }\n\n    for (var column = 0; column < columns; column++) {\n      if (column in matrix[row]) {\n        acc = func(acc, matrix[row][column], {\n          row: row,\n          column: column\n        });\n      }\n    }\n  }\n\n  return acc;\n}\n/** Creates an array of values by running each element in collection thru iteratee. */\n\nexport function map(func, matrix) {\n  return reduce(function (acc, value, point) {\n    mutableSet(point.row, point.column, func(value, point), acc);\n    return acc;\n  }, matrix, []);\n}\n/**\n * Converts all elements in row into a string separated by horizontalSeparator and each row string\n * to string separated by verticalSeparator\n */\n\nexport function join(matrix) {\n  var horizontalSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\\t\";\n  var verticalSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n  var joined = \"\";\n\n  var _getSize2 = getSize(matrix),\n      rows = _getSize2.rows,\n      columns = _getSize2.columns;\n\n  for (var row = 0; row < rows; row++) {\n    if (row) {\n      joined += verticalSeparator;\n    }\n\n    for (var column = 0; column < columns; column++) {\n      if (column) {\n        joined += horizontalSeparator;\n      }\n\n      if (matrix[row] && column in matrix[row]) {\n        joined += String(matrix[row][column]);\n      }\n    }\n  }\n\n  return joined;\n}\n/* Parses a CSV separated by a horizontalSeparator and verticalSeparator into a Matrix */\n\nexport function split(csv, getValue) {\n  var horizontalSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\t\";\n  var verticalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : /\\r\\n|\\n|\\r/;\n  return csv.split(verticalSeparator).map(function (row) {\n    return row.split(horizontalSeparator).map(getValue);\n  });\n}\n/** Returns whether the point exists in the matrix or not. */\n\nexport function has(row, column, matrix) {\n  var firstRow = matrix[0];\n  return firstRow && // validation\n  row >= 0 && column >= 0 && Number.isInteger(row) && Number.isInteger(column) && // first row length is in sync with other rows\n  column < firstRow.length && row < matrix.length;\n}\n\n/** Gets the size of matrix by returning its number of rows and columns */\nexport function getSize(matrix) {\n  var firstRow = matrix[0];\n  return {\n    columns: firstRow ? firstRow.length : 0,\n    rows: matrix.length\n  };\n}\nexport function padMatrix(matrix, desiredRows) {\n  var _getSize3 = getSize(matrix),\n      rows = _getSize3.rows;\n\n  var missingRows = desiredRows - rows;\n  if (rows === 0 || missingRows < 0) return matrix;\n  var paddingRow = matrix.slice(-1)[0].map(function (v) {\n    return _objectSpread({}, v, {\n      value: \"\"\n    });\n  });\n  return [].concat(_toConsumableArray(matrix), _toConsumableArray(Array(missingRows).fill(paddingRow)));\n}\n/** Creates an array of points (positive and/or negative) progressing from startPoint up to, but not including, endPoint. */\n\nexport function range(endPoint, startPoint) {\n  var points = [];\n  var columnsRange = startPoint.column !== endPoint.column ? _range(endPoint.column, startPoint.column) : startPoint.row !== endPoint.row ? [startPoint.column] : [];\n  var rowsRange = startPoint.row !== endPoint.row ? _range(endPoint.row, startPoint.row) : startPoint.column !== endPoint.column ? [startPoint.row] : [];\n\n  for (var i = 0; i < rowsRange.length; i++) {\n    var row = rowsRange[i];\n\n    for (var j = 0; j < columnsRange.length; j++) {\n      var column = columnsRange[j];\n      points.push({\n        row: row,\n        column: column\n      });\n    }\n  }\n\n  return points;\n}\n/** Like Matrix.range() but including endPoint. */\n\nexport var inclusiveRange = function inclusiveRange(endPoint, startPoint) {\n  return range({\n    row: endPoint.row + Math.sign(endPoint.row - startPoint.row),\n    column: endPoint.column + Math.sign(endPoint.column - startPoint.column)\n  }, startPoint);\n};\nexport function toArray(matrix, transform) {\n  var array = [];\n\n  for (var row = 0; row < matrix.length; row++) {\n    for (var column = 0; column < matrix.length; column++) {\n      var _value = matrix[row][column];\n      array.push(transform ? transform(_value) : _value);\n    }\n  }\n\n  return array;\n}"]},"metadata":{},"sourceType":"module"}