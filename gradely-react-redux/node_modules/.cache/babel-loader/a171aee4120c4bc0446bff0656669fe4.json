{"ast":null,"code":"import \"core-js/modules/es.string.replace\";\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { toLabel as _toLabel, extractLabel, error, ERROR_REF } from 'hot-formula-parser';\nimport { arrayEach, arrayFilter } from '../../helpers/array';\nimport { mixin } from '../../helpers/object';\nimport localHooks from '../../mixins/localHooks';\nimport { toUpperCaseFormula } from './utils';\nvar BARE_CELL_STRICT_REGEX = /^\\$?[A-Z]+\\$?\\d+$/;\nvar BARE_CELL_REGEX = /\\$?[A-Z]+\\$?\\d+/;\nvar CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ])/g;\nvar RANGE_REGEX = /\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+/g;\nvar CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ]))|(\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+)/g;\n/**\n * Component adds an ability to parse and modify formula expressions. It is designed for translating cell\n * coordinates and cell ranges in any direction. By default, component translates only relative coordinates but this\n * behavior can be overwritten by passing custom modifier which controls translating process.\n *\n * @class ExpressionModifier\n * @util\n */\n\nvar ExpressionModifier = /*#__PURE__*/function () {\n  function ExpressionModifier(expression) {\n    _classCallCheck(this, ExpressionModifier);\n    /**\n     * Formula expression to modify.\n     *\n     * @type {String}\n     */\n\n\n    this.expression = '';\n    /**\n     * Extracted cells and cells ranges.\n     *\n     * @type {Array}\n     */\n\n    this.cells = [];\n    /**\n     * Function which can modify default behaviour of how cells and cell ranges will be translated.\n     *\n     * @type {null|Function}\n     */\n\n    this.customModifier = null;\n\n    if (typeof expression === 'string') {\n      this.setExpression(expression);\n    }\n  }\n  /**\n   * Set formula expression to modify.\n   *\n   * @param {String} expression Formula expression to process.\n   * @returns {ExpressionModifier}\n   */\n\n\n  _createClass(ExpressionModifier, [{\n    key: \"setExpression\",\n    value: function setExpression(expression) {\n      this.cells.length = 0;\n      this.expression = toUpperCaseFormula(expression);\n\n      this._extractCells();\n\n      this._extractCellsRange();\n\n      return this;\n    }\n    /**\n     * Set function which can modify default behavior of how cells and cell ranges will be translated.\n     * The passed function will be called with 4 arguments:\n     *  - cell, A cell object with structure\n     *            like this: {start: {row, column}, end: {row, column}, origLabel, type: 'cell|range', refError, toLabel: () => {}}\n     *  - axis, Type of currently processing axis ('row' or 'column')\n     *  - delta, Number as distance to translate. Can be positive or negative.\n     *  - startFromIndex, Base index which translation will be applied from.\n     *\n     * the function must return an array with 3 items, where:\n     *  [\n     *    deltaStart, Number as a delta to translate first part of coordinates.\n     *    deltaEnd,   Number as a delta to translate second part of coordinates (if cell range is modified).\n     *    refError,   Defines an error which refers to the situation when translated cell overcrossed the data boundary.\n     *  ]\n     *\n     *\n     * @param {Function} customModifier Function with custom logic.\n     */\n\n  }, {\n    key: \"useCustomModifier\",\n    value: function useCustomModifier(customModifier) {\n      this.customModifier = customModifier;\n    }\n    /**\n     * Translate formula expression cells.\n     *\n     * @param {Object} delta Distance to move in proper direction.\n     * @param {Object} [startFrom] Coordinates which translation will be applied from.\n     * @returns {ExpressionModifier}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(_ref) {\n      var _this = this;\n\n      var deltaRow = _ref.row,\n          deltaColumn = _ref.column;\n      var startFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      arrayEach(this.cells, function (cell) {\n        if (deltaRow !== null && deltaRow !== void 0) {\n          _this._translateCell(cell, 'row', deltaRow, startFrom.row);\n        }\n\n        if (deltaColumn !== null && deltaColumn !== void 0) {\n          _this._translateCell(cell, 'column', deltaColumn, startFrom.column);\n        }\n      });\n      return this;\n    }\n    /**\n     * Translate object into string representation.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this2 = this;\n\n      var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {\n        var isSingleCell = match.indexOf(':') === -1;\n        var result = match;\n        var cellLabel = match;\n        var translatedCellLabel = null;\n\n        if (isSingleCell) {\n          cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;\n        }\n\n        var cell = _this2._searchCell(cellLabel);\n\n        if (cell) {\n          translatedCellLabel = cell.refError ? error(ERROR_REF) : cell.toLabel();\n\n          if (isSingleCell) {\n            result = match.replace(cellLabel, translatedCellLabel);\n          } else {\n            result = translatedCellLabel;\n          }\n        }\n\n        return result;\n      });\n\n      if (!expression.startsWith('=')) {\n        expression = \"=\".concat(expression);\n      }\n\n      return expression;\n    }\n    /**\n     * Translate single cell.\n     *\n     * @param {Object} cell Cell object.\n     * @param {String} axis Axis to modify.\n     * @param {Number} delta Distance to move.\n     * @param {Number} [startFromIndex] Base index which translation will be applied from.\n     * @private\n     */\n\n  }, {\n    key: \"_translateCell\",\n    value: function _translateCell(cell, axis, delta, startFromIndex) {\n      var start = cell.start,\n          end = cell.end;\n      var startIndex = start[axis].index;\n      var endIndex = end[axis].index;\n      var deltaStart = delta;\n      var deltaEnd = delta;\n      var refError = false;\n\n      if (this.customModifier) {\n        var _this$customModifier = this.customModifier(cell, axis, delta, startFromIndex);\n\n        var _this$customModifier2 = _slicedToArray(_this$customModifier, 3);\n\n        deltaStart = _this$customModifier2[0];\n        deltaEnd = _this$customModifier2[1];\n        refError = _this$customModifier2[2];\n      } else {\n        // By default only relative cells are translated, if meets absolute reset deltas to 0\n        if (start[axis].isAbsolute) {\n          deltaStart = 0;\n        }\n\n        if (end[axis].isAbsolute) {\n          deltaEnd = 0;\n        }\n      }\n\n      if (deltaStart && !refError) {\n        if (startIndex + deltaStart < 0) {\n          refError = true;\n        }\n\n        start[axis].index = Math.max(startIndex + deltaStart, 0);\n      }\n\n      if (deltaEnd && !refError) {\n        if (endIndex + deltaEnd < 0) {\n          refError = true;\n        }\n\n        end[axis].index = Math.max(endIndex + deltaEnd, 0);\n      }\n\n      if (refError) {\n        cell.refError = true;\n      }\n    }\n    /**\n     * Extract all cells from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCells\",\n    value: function _extractCells() {\n      var _this3 = this;\n\n      var matches = this.expression.match(CELL_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (coord) {\n        var cellCoords = coord.match(BARE_CELL_REGEX);\n\n        if (!cellCoords) {\n          return;\n        }\n\n        var _extractLabel = extractLabel(cellCoords[0]),\n            _extractLabel2 = _slicedToArray(_extractLabel, 2),\n            row = _extractLabel2[0],\n            column = _extractLabel2[1];\n\n        _this3.cells.push(_this3._createCell({\n          row: row,\n          column: column\n        }, {\n          row: row,\n          column: column\n        }, cellCoords[0]));\n      });\n    }\n    /**\n     * Extract all cells range from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCellsRange\",\n    value: function _extractCellsRange() {\n      var _this4 = this;\n\n      var matches = this.expression.match(RANGE_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (match) {\n        var _match$split = match.split(':'),\n            _match$split2 = _slicedToArray(_match$split, 2),\n            start = _match$split2[0],\n            end = _match$split2[1];\n\n        var _extractLabel3 = extractLabel(start),\n            _extractLabel4 = _slicedToArray(_extractLabel3, 2),\n            startRow = _extractLabel4[0],\n            startColumn = _extractLabel4[1];\n\n        var _extractLabel5 = extractLabel(end),\n            _extractLabel6 = _slicedToArray(_extractLabel5, 2),\n            endRow = _extractLabel6[0],\n            endColumn = _extractLabel6[1];\n\n        var startCell = {\n          row: startRow,\n          column: startColumn\n        };\n        var endCell = {\n          row: endRow,\n          column: endColumn\n        };\n\n        _this4.cells.push(_this4._createCell(startCell, endCell, match));\n      });\n    }\n    /**\n     * Search cell by its label.\n     *\n     * @param {String} label Cell label eq. `B4` or `$B$6`.\n     * @returns {Object|null}\n     * @private\n     */\n\n  }, {\n    key: \"_searchCell\",\n    value: function _searchCell(label) {\n      var _arrayFilter = arrayFilter(this.cells, function (cellMeta) {\n        return cellMeta.origLabel === label;\n      }),\n          _arrayFilter2 = _slicedToArray(_arrayFilter, 1),\n          cell = _arrayFilter2[0];\n\n      return cell || null;\n    }\n    /**\n     * Create object cell.\n     *\n     * @param {Object} start Start coordinates (top-left).\n     * @param {Object} end End coordinates (bottom-right).\n     * @param {String} label Original label name.\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"_createCell\",\n    value: function _createCell(start, end, label) {\n      return {\n        start: start,\n        end: end,\n        origLabel: label,\n        type: label.indexOf(':') === -1 ? 'cell' : 'range',\n        refError: false,\n        toLabel: function toLabel() {\n          var newLabel = _toLabel(this.start.row, this.start.column);\n\n          if (this.type === 'range') {\n            newLabel += \":\".concat(_toLabel(this.end.row, this.end.column));\n          }\n\n          return newLabel;\n        }\n      };\n    }\n  }]);\n\n  return ExpressionModifier;\n}();\n\nmixin(ExpressionModifier, localHooks);\nexport default ExpressionModifier;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/formulas/expressionModifier.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","toLabel","_toLabel","extractLabel","error","ERROR_REF","arrayEach","arrayFilter","mixin","localHooks","toUpperCaseFormula","BARE_CELL_STRICT_REGEX","BARE_CELL_REGEX","CELL_REGEX","RANGE_REGEX","CELL_AND_RANGE_REGEX","ExpressionModifier","expression","cells","customModifier","setExpression","_extractCells","_extractCellsRange","useCustomModifier","translate","_ref","_this","deltaRow","row","deltaColumn","column","startFrom","arguments","cell","_translateCell","_this2","replace","match","p1","p2","isSingleCell","indexOf","result","cellLabel","translatedCellLabel","test","_searchCell","refError","startsWith","concat","axis","delta","startFromIndex","start","end","startIndex","index","endIndex","deltaStart","deltaEnd","_this$customModifier","_this$customModifier2","isAbsolute","Math","max","_this3","matches","coord","cellCoords","_extractLabel","_extractLabel2","_createCell","_this4","_match$split","split","_match$split2","_extractLabel3","_extractLabel4","startRow","startColumn","_extractLabel5","_extractLabel6","endRow","endColumn","startCell","endCell","label","_arrayFilter","cellMeta","origLabel","_arrayFilter2","type","newLabel"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.exec\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.string.match\";\nimport \"core-js/modules/es.string.replace\";\nimport \"core-js/modules/es.string.split\";\nimport \"core-js/modules/es.string.starts-with\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { toLabel as _toLabel, extractLabel, error, ERROR_REF } from 'hot-formula-parser';\nimport { arrayEach, arrayFilter } from '../../helpers/array';\nimport { mixin } from '../../helpers/object';\nimport localHooks from '../../mixins/localHooks';\nimport { toUpperCaseFormula } from './utils';\nvar BARE_CELL_STRICT_REGEX = /^\\$?[A-Z]+\\$?\\d+$/;\nvar BARE_CELL_REGEX = /\\$?[A-Z]+\\$?\\d+/;\nvar CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ])/g;\nvar RANGE_REGEX = /\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+/g;\nvar CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ]))|(\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+)/g;\n/**\n * Component adds an ability to parse and modify formula expressions. It is designed for translating cell\n * coordinates and cell ranges in any direction. By default, component translates only relative coordinates but this\n * behavior can be overwritten by passing custom modifier which controls translating process.\n *\n * @class ExpressionModifier\n * @util\n */\n\nvar ExpressionModifier =\n/*#__PURE__*/\nfunction () {\n  function ExpressionModifier(expression) {\n    _classCallCheck(this, ExpressionModifier);\n\n    /**\n     * Formula expression to modify.\n     *\n     * @type {String}\n     */\n    this.expression = '';\n    /**\n     * Extracted cells and cells ranges.\n     *\n     * @type {Array}\n     */\n\n    this.cells = [];\n    /**\n     * Function which can modify default behaviour of how cells and cell ranges will be translated.\n     *\n     * @type {null|Function}\n     */\n\n    this.customModifier = null;\n\n    if (typeof expression === 'string') {\n      this.setExpression(expression);\n    }\n  }\n  /**\n   * Set formula expression to modify.\n   *\n   * @param {String} expression Formula expression to process.\n   * @returns {ExpressionModifier}\n   */\n\n\n  _createClass(ExpressionModifier, [{\n    key: \"setExpression\",\n    value: function setExpression(expression) {\n      this.cells.length = 0;\n      this.expression = toUpperCaseFormula(expression);\n\n      this._extractCells();\n\n      this._extractCellsRange();\n\n      return this;\n    }\n    /**\n     * Set function which can modify default behavior of how cells and cell ranges will be translated.\n     * The passed function will be called with 4 arguments:\n     *  - cell, A cell object with structure\n     *            like this: {start: {row, column}, end: {row, column}, origLabel, type: 'cell|range', refError, toLabel: () => {}}\n     *  - axis, Type of currently processing axis ('row' or 'column')\n     *  - delta, Number as distance to translate. Can be positive or negative.\n     *  - startFromIndex, Base index which translation will be applied from.\n     *\n     * the function must return an array with 3 items, where:\n     *  [\n     *    deltaStart, Number as a delta to translate first part of coordinates.\n     *    deltaEnd,   Number as a delta to translate second part of coordinates (if cell range is modified).\n     *    refError,   Defines an error which refers to the situation when translated cell overcrossed the data boundary.\n     *  ]\n     *\n     *\n     * @param {Function} customModifier Function with custom logic.\n     */\n\n  }, {\n    key: \"useCustomModifier\",\n    value: function useCustomModifier(customModifier) {\n      this.customModifier = customModifier;\n    }\n    /**\n     * Translate formula expression cells.\n     *\n     * @param {Object} delta Distance to move in proper direction.\n     * @param {Object} [startFrom] Coordinates which translation will be applied from.\n     * @returns {ExpressionModifier}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(_ref) {\n      var _this = this;\n\n      var deltaRow = _ref.row,\n          deltaColumn = _ref.column;\n      var startFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      arrayEach(this.cells, function (cell) {\n        if (deltaRow !== null && deltaRow !== void 0) {\n          _this._translateCell(cell, 'row', deltaRow, startFrom.row);\n        }\n\n        if (deltaColumn !== null && deltaColumn !== void 0) {\n          _this._translateCell(cell, 'column', deltaColumn, startFrom.column);\n        }\n      });\n      return this;\n    }\n    /**\n     * Translate object into string representation.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this2 = this;\n\n      var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {\n        var isSingleCell = match.indexOf(':') === -1;\n        var result = match;\n        var cellLabel = match;\n        var translatedCellLabel = null;\n\n        if (isSingleCell) {\n          cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;\n        }\n\n        var cell = _this2._searchCell(cellLabel);\n\n        if (cell) {\n          translatedCellLabel = cell.refError ? error(ERROR_REF) : cell.toLabel();\n\n          if (isSingleCell) {\n            result = match.replace(cellLabel, translatedCellLabel);\n          } else {\n            result = translatedCellLabel;\n          }\n        }\n\n        return result;\n      });\n\n      if (!expression.startsWith('=')) {\n        expression = \"=\".concat(expression);\n      }\n\n      return expression;\n    }\n    /**\n     * Translate single cell.\n     *\n     * @param {Object} cell Cell object.\n     * @param {String} axis Axis to modify.\n     * @param {Number} delta Distance to move.\n     * @param {Number} [startFromIndex] Base index which translation will be applied from.\n     * @private\n     */\n\n  }, {\n    key: \"_translateCell\",\n    value: function _translateCell(cell, axis, delta, startFromIndex) {\n      var start = cell.start,\n          end = cell.end;\n      var startIndex = start[axis].index;\n      var endIndex = end[axis].index;\n      var deltaStart = delta;\n      var deltaEnd = delta;\n      var refError = false;\n\n      if (this.customModifier) {\n        var _this$customModifier = this.customModifier(cell, axis, delta, startFromIndex);\n\n        var _this$customModifier2 = _slicedToArray(_this$customModifier, 3);\n\n        deltaStart = _this$customModifier2[0];\n        deltaEnd = _this$customModifier2[1];\n        refError = _this$customModifier2[2];\n      } else {\n        // By default only relative cells are translated, if meets absolute reset deltas to 0\n        if (start[axis].isAbsolute) {\n          deltaStart = 0;\n        }\n\n        if (end[axis].isAbsolute) {\n          deltaEnd = 0;\n        }\n      }\n\n      if (deltaStart && !refError) {\n        if (startIndex + deltaStart < 0) {\n          refError = true;\n        }\n\n        start[axis].index = Math.max(startIndex + deltaStart, 0);\n      }\n\n      if (deltaEnd && !refError) {\n        if (endIndex + deltaEnd < 0) {\n          refError = true;\n        }\n\n        end[axis].index = Math.max(endIndex + deltaEnd, 0);\n      }\n\n      if (refError) {\n        cell.refError = true;\n      }\n    }\n    /**\n     * Extract all cells from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCells\",\n    value: function _extractCells() {\n      var _this3 = this;\n\n      var matches = this.expression.match(CELL_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (coord) {\n        var cellCoords = coord.match(BARE_CELL_REGEX);\n\n        if (!cellCoords) {\n          return;\n        }\n\n        var _extractLabel = extractLabel(cellCoords[0]),\n            _extractLabel2 = _slicedToArray(_extractLabel, 2),\n            row = _extractLabel2[0],\n            column = _extractLabel2[1];\n\n        _this3.cells.push(_this3._createCell({\n          row: row,\n          column: column\n        }, {\n          row: row,\n          column: column\n        }, cellCoords[0]));\n      });\n    }\n    /**\n     * Extract all cells range from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCellsRange\",\n    value: function _extractCellsRange() {\n      var _this4 = this;\n\n      var matches = this.expression.match(RANGE_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (match) {\n        var _match$split = match.split(':'),\n            _match$split2 = _slicedToArray(_match$split, 2),\n            start = _match$split2[0],\n            end = _match$split2[1];\n\n        var _extractLabel3 = extractLabel(start),\n            _extractLabel4 = _slicedToArray(_extractLabel3, 2),\n            startRow = _extractLabel4[0],\n            startColumn = _extractLabel4[1];\n\n        var _extractLabel5 = extractLabel(end),\n            _extractLabel6 = _slicedToArray(_extractLabel5, 2),\n            endRow = _extractLabel6[0],\n            endColumn = _extractLabel6[1];\n\n        var startCell = {\n          row: startRow,\n          column: startColumn\n        };\n        var endCell = {\n          row: endRow,\n          column: endColumn\n        };\n\n        _this4.cells.push(_this4._createCell(startCell, endCell, match));\n      });\n    }\n    /**\n     * Search cell by its label.\n     *\n     * @param {String} label Cell label eq. `B4` or `$B$6`.\n     * @returns {Object|null}\n     * @private\n     */\n\n  }, {\n    key: \"_searchCell\",\n    value: function _searchCell(label) {\n      var _arrayFilter = arrayFilter(this.cells, function (cellMeta) {\n        return cellMeta.origLabel === label;\n      }),\n          _arrayFilter2 = _slicedToArray(_arrayFilter, 1),\n          cell = _arrayFilter2[0];\n\n      return cell || null;\n    }\n    /**\n     * Create object cell.\n     *\n     * @param {Object} start Start coordinates (top-left).\n     * @param {Object} end End coordinates (bottom-right).\n     * @param {String} label Original label name.\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"_createCell\",\n    value: function _createCell(start, end, label) {\n      return {\n        start: start,\n        end: end,\n        origLabel: label,\n        type: label.indexOf(':') === -1 ? 'cell' : 'range',\n        refError: false,\n        toLabel: function toLabel() {\n          var newLabel = _toLabel(this.start.row, this.start.column);\n\n          if (this.type === 'range') {\n            newLabel += \":\".concat(_toLabel(this.end.row, this.end.column));\n          }\n\n          return newLabel;\n        }\n      };\n    }\n  }]);\n\n  return ExpressionModifier;\n}();\n\nmixin(ExpressionModifier, localHooks);\nexport default ExpressionModifier;"]},"metadata":{},"sourceType":"module"}