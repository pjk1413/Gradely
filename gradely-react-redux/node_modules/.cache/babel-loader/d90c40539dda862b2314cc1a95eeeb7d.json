{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { arrayEach } from '../../helpers/array';\nimport { rangeEach } from '../../helpers/number';\nimport { hasOwnProperty } from '../../helpers/object';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Data class provider responsible for providing a set of range data types, necessary for calculating formulas.\n * Those methods strongly using hot.getData and hot.getSourceData methods with some changes. Data provider additionally\n * collects all changes added to the data source to make them available faster than by using\n * hot.getData and hot.getSourceData methods.\n *\n * @class DataProvider\n * @util\n */\n\nvar DataProvider = /*#__PURE__*/function () {\n  function DataProvider(hot) {\n    _classCallCheck(this, DataProvider);\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n\n\n    this.hot = hot;\n    /**\n     * Collected changes applied into editors or by calling public Handsontable API. This is require to provide\n     * fresh data applied into spreadsheet before they will be available from the public API.\n     *\n     * @type {Object}\n     */\n\n    this.changes = {};\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n  }\n  /**\n   * Collect all data changes applied to the Handsontable to make them available later.\n   *\n   * @param {Number} row Physical row index.\n   * @param {Number} column Physical column index.\n   * @param {*} value Value to store.\n   */\n\n\n  _createClass(DataProvider, [{\n    key: \"collectChanges\",\n    value: function collectChanges(row, column, value) {\n      this.changes[this._coordId(row, column)] = value;\n    }\n    /**\n     * Clear all collected changes.\n     */\n\n  }, {\n    key: \"clearChanges\",\n    value: function clearChanges() {\n      this.changes = {};\n    }\n    /**\n     * Check if provided coordinates match to the table range data.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual row index.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInDataRange\",\n    value: function isInDataRange(visualRow, visualColumn) {\n      return visualRow >= 0 && visualRow < this.hot.countRows() && visualColumn >= 0 && visualColumn < this.hot.countCols();\n    }\n    /**\n     * Get calculated data at specified cell.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getDataAtCell\",\n    value: function getDataAtCell(visualRow, visualColumn) {\n      var id = this._coordId.apply(this, _toConsumableArray(this.t.toPhysical(visualRow, visualColumn)));\n\n      var result;\n\n      if (hasOwnProperty(this.changes, id)) {\n        result = this.changes[id];\n      } else {\n        result = this.hot.getDataAtCell(visualRow, visualColumn);\n      }\n\n      return result;\n    }\n    /**\n     * Get calculated data at specified range.\n     *\n     * @param {Number} [visualRow1] Visual row index.\n     * @param {Number} [visualColumn1] Visual column index.\n     * @param {Number} [visualRow2] Visual row index.\n     * @param {Number} [visualColumn2] Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getDataByRange\",\n    value: function getDataByRange(visualRow1, visualColumn1, visualRow2, visualColumn2) {\n      var _this = this;\n\n      var result = this.hot.getData(visualRow1, visualColumn1, visualRow2, visualColumn2);\n      arrayEach(result, function (rowData, rowIndex) {\n        arrayEach(rowData, function (value, columnIndex) {\n          var id = _this._coordId.apply(_this, _toConsumableArray(_this.t.toPhysical(rowIndex + visualRow1, columnIndex + visualColumn1)));\n\n          if (hasOwnProperty(_this.changes, id)) {\n            result[rowIndex][columnIndex] = _this.changes[id];\n          }\n        });\n      });\n      return result;\n    }\n    /**\n     * Get source data at specified physical cell.\n     *\n     * @param {Number} physicalRow Physical row index.\n     * @param {Number} physicalColumn Physical column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getSourceDataAtCell\",\n    value: function getSourceDataAtCell(physicalRow, physicalColumn) {\n      var id = this._coordId(physicalRow, physicalColumn);\n\n      var result;\n\n      if (hasOwnProperty(this.changes, id)) {\n        result = this.changes[id];\n      } else {\n        result = this.hot.getSourceDataAtCell(physicalRow, physicalColumn);\n      }\n\n      return result;\n    }\n    /**\n     * Get source data at specified physical range.\n     *\n     * @param {Number} [physicalRow1] Physical row index.\n     * @param {Number} [physicalColumn1] Physical column index.\n     * @param {Number} [physicalRow2] Physical row index.\n     * @param {Number} [physicalColumn2] Physical column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getSourceDataByRange\",\n    value: function getSourceDataByRange(physicalRow1, physicalColumn1, physicalRow2, physicalColumn2) {\n      return this.hot.getSourceDataArray(physicalRow1, physicalColumn1, physicalRow2, physicalColumn2);\n    }\n    /**\n     * Get source data at specified visual cell.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getRawDataAtCell\",\n    value: function getRawDataAtCell(visualRow, visualColumn) {\n      return this.getSourceDataAtCell.apply(this, _toConsumableArray(this.t.toPhysical(visualRow, visualColumn)));\n    }\n    /**\n     * Get source data at specified visual range.\n     *\n     * @param {Number} [visualRow1] Visual row index.\n     * @param {Number} [visualColumn1] Visual column index.\n     * @param {Number} [visualRow2] Visual row index.\n     * @param {Number} [visualColumn2] Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRawDataByRange\",\n    value: function getRawDataByRange(visualRow1, visualColumn1, visualRow2, visualColumn2) {\n      var _this2 = this;\n\n      var data = [];\n      rangeEach(visualRow1, visualRow2, function (visualRow) {\n        var row = [];\n        rangeEach(visualColumn1, visualColumn2, function (visualColumn) {\n          var _this2$t$toPhysical = _this2.t.toPhysical(visualRow, visualColumn),\n              _this2$t$toPhysical2 = _slicedToArray(_this2$t$toPhysical, 2),\n              physicalRow = _this2$t$toPhysical2[0],\n              physicalColumn = _this2$t$toPhysical2[1];\n\n          var id = _this2._coordId(physicalRow, physicalColumn);\n\n          if (hasOwnProperty(_this2.changes, id)) {\n            row.push(_this2.changes[id]);\n          } else {\n            row.push(_this2.getSourceDataAtCell(physicalRow, physicalColumn));\n          }\n        });\n        data.push(row);\n      });\n      return data;\n    }\n    /**\n     * Update source data.\n     *\n     * @param {Number} physicalRow Physical row index.\n     * @param {Number} physicalColumn Physical row index.\n     * @param {*} value Value to update.\n     */\n\n  }, {\n    key: \"updateSourceData\",\n    value: function updateSourceData(physicalRow, physicalColumn, value) {\n      this.hot.getSourceData()[physicalRow][this.hot.colToProp(physicalColumn)] = value;\n    }\n    /**\n     * Generate cell coordinates id where the data changes will be stored.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {String}\n     * @private\n     */\n\n  }, {\n    key: \"_coordId\",\n    value: function _coordId(row, column) {\n      return \"\".concat(row, \":\").concat(column);\n    }\n    /**\n     * Destroy class.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.changes = null;\n      this.t = null;\n    }\n  }]);\n\n  return DataProvider;\n}();\n\nexport default DataProvider;","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/plugins/formulas/dataProvider.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","from","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","arrayEach","rangeEach","hasOwnProperty","getTranslator","DataProvider","hot","changes","t","collectChanges","row","column","_coordId","clearChanges","isInDataRange","visualRow","visualColumn","countRows","countCols","getDataAtCell","id","apply","toPhysical","result","getDataByRange","visualRow1","visualColumn1","visualRow2","visualColumn2","_this","getData","rowData","rowIndex","columnIndex","getSourceDataAtCell","physicalRow","physicalColumn","getSourceDataByRange","physicalRow1","physicalColumn1","physicalRow2","physicalColumn2","getSourceDataArray","getRawDataAtCell","getRawDataByRange","_this2","data","_this2$t$toPhysical","_this2$t$toPhysical2","updateSourceData","getSourceData","colToProp","concat","destroy"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { arrayEach } from '../../helpers/array';\nimport { rangeEach } from '../../helpers/number';\nimport { hasOwnProperty } from '../../helpers/object';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Data class provider responsible for providing a set of range data types, necessary for calculating formulas.\n * Those methods strongly using hot.getData and hot.getSourceData methods with some changes. Data provider additionally\n * collects all changes added to the data source to make them available faster than by using\n * hot.getData and hot.getSourceData methods.\n *\n * @class DataProvider\n * @util\n */\n\nvar DataProvider =\n/*#__PURE__*/\nfunction () {\n  function DataProvider(hot) {\n    _classCallCheck(this, DataProvider);\n\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    this.hot = hot;\n    /**\n     * Collected changes applied into editors or by calling public Handsontable API. This is require to provide\n     * fresh data applied into spreadsheet before they will be available from the public API.\n     *\n     * @type {Object}\n     */\n\n    this.changes = {};\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n  }\n  /**\n   * Collect all data changes applied to the Handsontable to make them available later.\n   *\n   * @param {Number} row Physical row index.\n   * @param {Number} column Physical column index.\n   * @param {*} value Value to store.\n   */\n\n\n  _createClass(DataProvider, [{\n    key: \"collectChanges\",\n    value: function collectChanges(row, column, value) {\n      this.changes[this._coordId(row, column)] = value;\n    }\n    /**\n     * Clear all collected changes.\n     */\n\n  }, {\n    key: \"clearChanges\",\n    value: function clearChanges() {\n      this.changes = {};\n    }\n    /**\n     * Check if provided coordinates match to the table range data.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual row index.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInDataRange\",\n    value: function isInDataRange(visualRow, visualColumn) {\n      return visualRow >= 0 && visualRow < this.hot.countRows() && visualColumn >= 0 && visualColumn < this.hot.countCols();\n    }\n    /**\n     * Get calculated data at specified cell.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getDataAtCell\",\n    value: function getDataAtCell(visualRow, visualColumn) {\n      var id = this._coordId.apply(this, _toConsumableArray(this.t.toPhysical(visualRow, visualColumn)));\n\n      var result;\n\n      if (hasOwnProperty(this.changes, id)) {\n        result = this.changes[id];\n      } else {\n        result = this.hot.getDataAtCell(visualRow, visualColumn);\n      }\n\n      return result;\n    }\n    /**\n     * Get calculated data at specified range.\n     *\n     * @param {Number} [visualRow1] Visual row index.\n     * @param {Number} [visualColumn1] Visual column index.\n     * @param {Number} [visualRow2] Visual row index.\n     * @param {Number} [visualColumn2] Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getDataByRange\",\n    value: function getDataByRange(visualRow1, visualColumn1, visualRow2, visualColumn2) {\n      var _this = this;\n\n      var result = this.hot.getData(visualRow1, visualColumn1, visualRow2, visualColumn2);\n      arrayEach(result, function (rowData, rowIndex) {\n        arrayEach(rowData, function (value, columnIndex) {\n          var id = _this._coordId.apply(_this, _toConsumableArray(_this.t.toPhysical(rowIndex + visualRow1, columnIndex + visualColumn1)));\n\n          if (hasOwnProperty(_this.changes, id)) {\n            result[rowIndex][columnIndex] = _this.changes[id];\n          }\n        });\n      });\n      return result;\n    }\n    /**\n     * Get source data at specified physical cell.\n     *\n     * @param {Number} physicalRow Physical row index.\n     * @param {Number} physicalColumn Physical column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getSourceDataAtCell\",\n    value: function getSourceDataAtCell(physicalRow, physicalColumn) {\n      var id = this._coordId(physicalRow, physicalColumn);\n\n      var result;\n\n      if (hasOwnProperty(this.changes, id)) {\n        result = this.changes[id];\n      } else {\n        result = this.hot.getSourceDataAtCell(physicalRow, physicalColumn);\n      }\n\n      return result;\n    }\n    /**\n     * Get source data at specified physical range.\n     *\n     * @param {Number} [physicalRow1] Physical row index.\n     * @param {Number} [physicalColumn1] Physical column index.\n     * @param {Number} [physicalRow2] Physical row index.\n     * @param {Number} [physicalColumn2] Physical column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getSourceDataByRange\",\n    value: function getSourceDataByRange(physicalRow1, physicalColumn1, physicalRow2, physicalColumn2) {\n      return this.hot.getSourceDataArray(physicalRow1, physicalColumn1, physicalRow2, physicalColumn2);\n    }\n    /**\n     * Get source data at specified visual cell.\n     *\n     * @param {Number} visualRow Visual row index.\n     * @param {Number} visualColumn Visual column index.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getRawDataAtCell\",\n    value: function getRawDataAtCell(visualRow, visualColumn) {\n      return this.getSourceDataAtCell.apply(this, _toConsumableArray(this.t.toPhysical(visualRow, visualColumn)));\n    }\n    /**\n     * Get source data at specified visual range.\n     *\n     * @param {Number} [visualRow1] Visual row index.\n     * @param {Number} [visualColumn1] Visual column index.\n     * @param {Number} [visualRow2] Visual row index.\n     * @param {Number} [visualColumn2] Visual column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRawDataByRange\",\n    value: function getRawDataByRange(visualRow1, visualColumn1, visualRow2, visualColumn2) {\n      var _this2 = this;\n\n      var data = [];\n      rangeEach(visualRow1, visualRow2, function (visualRow) {\n        var row = [];\n        rangeEach(visualColumn1, visualColumn2, function (visualColumn) {\n          var _this2$t$toPhysical = _this2.t.toPhysical(visualRow, visualColumn),\n              _this2$t$toPhysical2 = _slicedToArray(_this2$t$toPhysical, 2),\n              physicalRow = _this2$t$toPhysical2[0],\n              physicalColumn = _this2$t$toPhysical2[1];\n\n          var id = _this2._coordId(physicalRow, physicalColumn);\n\n          if (hasOwnProperty(_this2.changes, id)) {\n            row.push(_this2.changes[id]);\n          } else {\n            row.push(_this2.getSourceDataAtCell(physicalRow, physicalColumn));\n          }\n        });\n        data.push(row);\n      });\n      return data;\n    }\n    /**\n     * Update source data.\n     *\n     * @param {Number} physicalRow Physical row index.\n     * @param {Number} physicalColumn Physical row index.\n     * @param {*} value Value to update.\n     */\n\n  }, {\n    key: \"updateSourceData\",\n    value: function updateSourceData(physicalRow, physicalColumn, value) {\n      this.hot.getSourceData()[physicalRow][this.hot.colToProp(physicalColumn)] = value;\n    }\n    /**\n     * Generate cell coordinates id where the data changes will be stored.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {String}\n     * @private\n     */\n\n  }, {\n    key: \"_coordId\",\n    value: function _coordId(row, column) {\n      return \"\".concat(row, \":\").concat(column);\n    }\n    /**\n     * Destroy class.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.changes = null;\n      this.t = null;\n    }\n  }]);\n\n  return DataProvider;\n}();\n\nexport default DataProvider;"]},"metadata":{},"sourceType":"module"}