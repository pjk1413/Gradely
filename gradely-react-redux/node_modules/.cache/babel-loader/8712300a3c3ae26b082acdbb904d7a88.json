{"ast":null,"code":"import { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"insert_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be increased\n *   by \"amount\" of times (eq: D4 to D5, $F$5 to $F$6);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'insert_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be inserted.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider;\n  var translate = [amount, 0];\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: amount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var deltaStart = delta;\n  var deltaEnd = delta; // Do not translate cells above inserted row or on the left of inserted column\n\n  if (startFromIndex > startIndex) {\n    deltaStart = 0;\n  }\n\n  if (startFromIndex > endIndex) {\n    deltaEnd = 0;\n  }\n\n  return [deltaStart, deltaEnd, false];\n}","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react/node_modules/handsontable/es/plugins/formulas/alterOperation/insertRow.js"],"names":["arrayEach","cellCoordFactory","isFormulaExpression","CellValue","ExpressionModifier","OPERATION_NAME","operate","start","amount","modifyFormula","arguments","length","undefined","matrix","dataProvider","translate","cellReferences","cell","row","translateTo","apply","data","origRow","origColumn","column","setState","STATE_OUT_OFF_DATE","value","getSourceDataAtCell","startCoord","expModifier","useCustomModifier","customTranslateModifier","updateSourceData","toString","axis","delta","startFromIndex","end","startIndex","index","endIndex","deltaStart","deltaEnd"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"insert_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be increased\n *   by \"amount\" of times (eq: D4 to D5, $F$5 to $F$6);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'insert_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be inserted.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider;\n  var translate = [amount, 0];\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: amount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var deltaStart = delta;\n  var deltaEnd = delta; // Do not translate cells above inserted row or on the left of inserted column\n\n  if (startFromIndex > startIndex) {\n    deltaStart = 0;\n  }\n\n  if (startFromIndex > endIndex) {\n    deltaEnd = 0;\n  }\n\n  return [deltaStart, deltaEnd, false];\n}"]},"metadata":{},"sourceType":"module"}