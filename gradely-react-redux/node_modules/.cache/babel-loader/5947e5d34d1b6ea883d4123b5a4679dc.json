{"ast":null,"code":"import { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"remove_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be decreased\n *   by \"amount\" of times (eq: D4 to D3, $F$5 to $F$4);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'remove_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be removed.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var rowsAmount = -amount;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider,\n      sheet = this.sheet;\n  var translate = [rowsAmount, 0];\n  var indexOffset = Math.abs(rowsAmount) - 1;\n  var removedCellRef = matrix.removeCellRefsAtRange({\n    row: start\n  }, {\n    row: start + indexOffset\n  });\n  var toRemove = [];\n  arrayEach(matrix.data, function (cell) {\n    arrayEach(removedCellRef, function (cellRef) {\n      if (!cell.hasPrecedent(cellRef)) {\n        return;\n      }\n\n      cell.removePrecedent(cellRef);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n      arrayEach(sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n    });\n\n    if (cell.row >= start && cell.row <= start + indexOffset) {\n      toRemove.push(cell);\n    }\n  });\n  matrix.remove(toRemove);\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: rowsAmount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end,\n      type = cell.type;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var indexOffset = Math.abs(delta) - 1;\n  var deltaStart = delta;\n  var deltaEnd = delta;\n  var refError = false; // Mark all cells as #REF! which refer to removed cells between startFromIndex and startFromIndex + delta\n\n  if (startIndex >= startFromIndex && endIndex <= startFromIndex + indexOffset) {\n    refError = true;\n  } // Decrement all cells below startFromIndex\n\n\n  if (!refError && type === 'cell') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n      deltaEnd = 0;\n    }\n  }\n\n  if (!refError && type === 'range') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n    }\n\n    if (startFromIndex > endIndex) {\n      deltaEnd = 0;\n    } else if (endIndex <= startFromIndex + indexOffset) {\n      deltaEnd -= Math.min(endIndex - (startFromIndex + indexOffset), 0);\n    }\n  }\n\n  if (startIndex + deltaStart < 0) {\n    deltaStart -= startIndex + deltaStart;\n  }\n\n  return [deltaStart, deltaEnd, refError];\n}","map":{"version":3,"sources":["C:/Users/pjk14/Desktop/Gradely/gradely-react-redux/node_modules/handsontable/es/plugins/formulas/alterOperation/removeRow.js"],"names":["arrayEach","cellCoordFactory","isFormulaExpression","CellValue","ExpressionModifier","OPERATION_NAME","operate","start","amount","modifyFormula","arguments","length","undefined","rowsAmount","matrix","dataProvider","sheet","translate","indexOffset","Math","abs","removedCellRef","removeCellRefsAtRange","row","toRemove","data","cell","cellRef","hasPrecedent","removePrecedent","setState","STATE_OUT_OFF_DATE","getCellDependencies","column","cellValue","push","remove","cellReferences","translateTo","apply","origRow","origColumn","value","getSourceDataAtCell","startCoord","expModifier","useCustomModifier","customTranslateModifier","updateSourceData","toString","axis","delta","startFromIndex","end","type","startIndex","index","endIndex","deltaStart","deltaEnd","refError","min"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"remove_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be decreased\n *   by \"amount\" of times (eq: D4 to D3, $F$5 to $F$4);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'remove_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be removed.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var rowsAmount = -amount;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider,\n      sheet = this.sheet;\n  var translate = [rowsAmount, 0];\n  var indexOffset = Math.abs(rowsAmount) - 1;\n  var removedCellRef = matrix.removeCellRefsAtRange({\n    row: start\n  }, {\n    row: start + indexOffset\n  });\n  var toRemove = [];\n  arrayEach(matrix.data, function (cell) {\n    arrayEach(removedCellRef, function (cellRef) {\n      if (!cell.hasPrecedent(cellRef)) {\n        return;\n      }\n\n      cell.removePrecedent(cellRef);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n      arrayEach(sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n    });\n\n    if (cell.row >= start && cell.row <= start + indexOffset) {\n      toRemove.push(cell);\n    }\n  });\n  matrix.remove(toRemove);\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: rowsAmount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end,\n      type = cell.type;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var indexOffset = Math.abs(delta) - 1;\n  var deltaStart = delta;\n  var deltaEnd = delta;\n  var refError = false; // Mark all cells as #REF! which refer to removed cells between startFromIndex and startFromIndex + delta\n\n  if (startIndex >= startFromIndex && endIndex <= startFromIndex + indexOffset) {\n    refError = true;\n  } // Decrement all cells below startFromIndex\n\n\n  if (!refError && type === 'cell') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n      deltaEnd = 0;\n    }\n  }\n\n  if (!refError && type === 'range') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n    }\n\n    if (startFromIndex > endIndex) {\n      deltaEnd = 0;\n    } else if (endIndex <= startFromIndex + indexOffset) {\n      deltaEnd -= Math.min(endIndex - (startFromIndex + indexOffset), 0);\n    }\n  }\n\n  if (startIndex + deltaStart < 0) {\n    deltaStart -= startIndex + deltaStart;\n  }\n\n  return [deltaStart, deltaEnd, refError];\n}"]},"metadata":{},"sourceType":"module"}